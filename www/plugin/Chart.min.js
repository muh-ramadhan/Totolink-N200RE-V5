!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = e(
        (function () {
          try {
            return require("moment");
          } catch (t) {}
        })()
      ))
    : "function" == typeof define && define.amd
    ? define(["require"], function (t) {
        return e(
          (function () {
            try {
              return t("moment");
            } catch (t) {}
          })()
        );
      })
    : (t.Chart = e(t.moment));
})(this, function (n) {
  "use strict";
  n = n && n.hasOwnProperty("default") ? n.default : n;
  var B = {
    rgb2hsl: N,
    rgb2hsv: W,
    rgb2hwb: V,
    rgb2cmyk: E,
    rgb2keyword: H,
    rgb2xyz: Y,
    rgb2lab: U,
    rgb2lch: function (t) {
      return tt(U(t));
    },
    hsl2rgb: X,
    hsl2hsv: function (t) {
      var e = t[0],
        i = t[1] / 100,
        t = t[2] / 100;
      return 0 == t
        ? [0, 0, 0]
        : [
            e,
            ((2 * (i *= (t *= 2) <= 1 ? t : 2 - t)) / (t + i)) * 100,
            ((t + i) / 2) * 100,
          ];
    },
    hsl2hwb: function (t) {
      return V(X(t));
    },
    hsl2cmyk: function (t) {
      return E(X(t));
    },
    hsl2keyword: function (t) {
      return H(X(t));
    },
    hsv2rgb: K,
    hsv2hsl: function (t) {
      var e = t[0],
        i = t[1] / 100,
        t = t[2] / 100;
      return [
        e,
        100 * ((i * t) / ((e = (2 - i) * t) <= 1 ? e : 2 - e) || 0),
        100 * (e /= 2),
      ];
    },
    hsv2hwb: function (t) {
      return V(K(t));
    },
    hsv2cmyk: function (t) {
      return E(K(t));
    },
    hsv2keyword: function (t) {
      return H(K(t));
    },
    hwb2rgb: G,
    hwb2hsl: function (t) {
      return N(G(t));
    },
    hwb2hsv: function (t) {
      return W(G(t));
    },
    hwb2cmyk: function (t) {
      return E(G(t));
    },
    hwb2keyword: function (t) {
      return H(G(t));
    },
    cmyk2rgb: Z,
    cmyk2hsl: function (t) {
      return N(Z(t));
    },
    cmyk2hsv: function (t) {
      return W(Z(t));
    },
    cmyk2hwb: function (t) {
      return V(Z(t));
    },
    cmyk2keyword: function (t) {
      return H(Z(t));
    },
    keyword2rgb: e,
    keyword2hsl: function (t) {
      return N(e(t));
    },
    keyword2hsv: function (t) {
      return W(e(t));
    },
    keyword2hwb: function (t) {
      return V(e(t));
    },
    keyword2cmyk: function (t) {
      return E(e(t));
    },
    keyword2lab: function (t) {
      return U(e(t));
    },
    keyword2xyz: function (t) {
      return Y(e(t));
    },
    xyz2rgb: $,
    xyz2lab: J,
    xyz2lch: function (t) {
      return tt(J(t));
    },
    lab2xyz: Q,
    lab2rgb: et,
    lab2lch: tt,
    lch2lab: it,
    lch2xyz: function (t) {
      return Q(it(t));
    },
    lch2rgb: function (t) {
      return et(it(t));
    },
  };
  function N(t) {
    var e,
      i = t[0] / 255,
      n = t[1] / 255,
      t = t[2] / 255,
      a = Math.min(i, n, t),
      o = Math.max(i, n, t),
      r = o - a;
    return (
      o == a
        ? (e = 0)
        : i == o
        ? (e = (n - t) / r)
        : n == o
        ? (e = 2 + (t - i) / r)
        : t == o && (e = 4 + (i - n) / r),
      (e = Math.min(60 * e, 360)) < 0 && (e += 360),
      (t = (a + o) / 2),
      [
        e,
        100 * (o == a ? 0 : t <= 0.5 ? r / (o + a) : r / (2 - o - a)),
        100 * t,
      ]
    );
  }
  function W(t) {
    var e,
      i = t[0],
      n = t[1],
      t = t[2],
      a = Math.min(i, n, t),
      o = Math.max(i, n, t),
      r = o - a,
      s = 0 == o ? 0 : ((r / o) * 1e3) / 10;
    return (
      o == a
        ? (e = 0)
        : i == o
        ? (e = (n - t) / r)
        : n == o
        ? (e = 2 + (t - i) / r)
        : t == o && (e = 4 + (i - n) / r),
      (e = Math.min(60 * e, 360)) < 0 && (e += 360),
      [e, s, ((o / 255) * 1e3) / 10]
    );
  }
  function V(t) {
    var e = t[0],
      i = t[1],
      n = t[2];
    return [
      N(t)[0],
      (1 / 255) * Math.min(e, Math.min(i, n)) * 100,
      100 * (1 - (1 / 255) * Math.max(e, Math.max(i, n))),
    ];
  }
  function E(t) {
    var e = t[0] / 255,
      i = t[1] / 255,
      t = t[2] / 255;
    return [
      100 * ((1 - e - (e = Math.min(1 - e, 1 - i, 1 - t))) / (1 - e) || 0),
      100 * ((1 - i - e) / (1 - e) || 0),
      100 * ((1 - t - e) / (1 - e) || 0),
      100 * e,
    ];
  }
  function H(t) {
    return ot[JSON.stringify(t)];
  }
  function Y(t) {
    var e = t[0] / 255,
      i = t[1] / 255,
      t = t[2] / 255;
    return [
      100 *
        (0.4124 *
          (e = 0.04045 < e ? Math.pow((0.055 + e) / 1.055, 2.4) : e / 12.92) +
          0.3576 *
            (i = 0.04045 < i ? Math.pow((0.055 + i) / 1.055, 2.4) : i / 12.92) +
          0.1805 *
            (t = 0.04045 < t ? Math.pow((0.055 + t) / 1.055, 2.4) : t / 12.92)),
      100 * (0.2126 * e + 0.7152 * i + 0.0722 * t),
      100 * (0.0193 * e + 0.1192 * i + 0.9505 * t),
    ];
  }
  function U(t) {
    var t = Y(t),
      e = t[0],
      i = t[1],
      t = t[2];
    return (
      (i /= 100),
      (t /= 108.883),
      (e =
        0.008856 < (e /= 95.047) ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116),
      [
        116 * (i = 0.008856 < i ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) -
          16,
        500 * (e - i),
        200 * (i - (0.008856 < t ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116)),
      ]
    );
  }
  function X(t) {
    var e,
      i,
      n,
      a = t[0] / 360,
      o = t[1] / 100,
      t = t[2] / 100;
    if (0 == o) return [(n = 255 * t), n, n];
    for (
      var r = 2 * t - (e = t < 0.5 ? t * (1 + o) : t + o - t * o),
        s = [0, 0, 0],
        l = 0;
      l < 3;
      l++
    )
      (i = a + (1 / 3) * -(l - 1)) < 0 && i++,
        1 < i && i--,
        (s[l] =
          255 *
          (n =
            6 * i < 1
              ? r + 6 * (e - r) * i
              : 2 * i < 1
              ? e
              : 3 * i < 2
              ? r + (e - r) * (2 / 3 - i) * 6
              : r));
    return s;
  }
  function K(t) {
    var e = t[0] / 60,
      i = t[1] / 100,
      n = t[2] / 100,
      t = Math.floor(e) % 6,
      e = e - Math.floor(e),
      a = 255 * n * (1 - i),
      o = 255 * n * (1 - i * e),
      r = 255 * n * (1 - i * (1 - e));
    switch (((n *= 255), t)) {
      case 0:
        return [n, r, a];
      case 1:
        return [o, n, a];
      case 2:
        return [a, n, r];
      case 3:
        return [a, o, n];
      case 4:
        return [r, a, n];
      case 5:
        return [n, a, o];
    }
  }
  function G(t) {
    var e,
      i,
      n = t[0] / 360,
      a = t[1] / 100,
      t = t[2] / 100,
      o = a + t;
    switch (
      (1 < o && ((a /= o), (t /= o)),
      (n = 6 * n - (o = Math.floor(6 * n))),
      (i = a + (n = 0 != (1 & o) ? 1 - n : n) * ((e = 1 - t) - a)),
      o)
    ) {
      default:
      case 6:
      case 0:
        (r = e), (g = i), (b = a);
        break;
      case 1:
        (r = i), (g = e), (b = a);
        break;
      case 2:
        (r = a), (g = e), (b = i);
        break;
      case 3:
        (r = a), (g = i), (b = e);
        break;
      case 4:
        (r = i), (g = a), (b = e);
        break;
      case 5:
        (r = e), (g = a), (b = i);
    }
    return [255 * r, 255 * g, 255 * b];
  }
  function Z(t) {
    var e = t[0] / 100,
      i = t[1] / 100,
      n = t[2] / 100,
      t = t[3] / 100;
    return [
      255 * (1 - Math.min(1, e * (1 - t) + t)),
      255 * (1 - Math.min(1, i * (1 - t) + t)),
      255 * (1 - Math.min(1, n * (1 - t) + t)),
    ];
  }
  function $(t) {
    var e = t[0] / 100,
      i = t[1] / 100,
      t = t[2] / 100,
      n = -0.9689 * e + 1.8758 * i + 0.0415 * t,
      a = 0.0557 * e + -0.204 * i + 1.057 * t,
      e =
        0.0031308 < (e = 3.2406 * e + -1.5372 * i + -0.4986 * t)
          ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055
          : 12.92 * e;
    return (
      (n = 0.0031308 < n ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n),
      (a = 0.0031308 < a ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : 12.92 * a),
      [
        255 * (e = Math.min(Math.max(0, e), 1)),
        255 * (n = Math.min(Math.max(0, n), 1)),
        255 * (a = Math.min(Math.max(0, a), 1)),
      ]
    );
  }
  function J(t) {
    var e = t[0],
      i = t[1],
      t = t[2];
    return (
      (i /= 100),
      (t /= 108.883),
      (e =
        0.008856 < (e /= 95.047) ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116),
      [
        116 * (i = 0.008856 < i ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) -
          16,
        500 * (e - i),
        200 * (i - (0.008856 < t ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116)),
      ]
    );
  }
  function Q(t) {
    var e,
      i,
      n,
      a = t[0],
      o = t[1],
      t = t[2],
      a =
        a <= 8
          ? ((i = (100 * a) / 903.3) / 100) * 7.787 + 16 / 116
          : ((i = 100 * Math.pow((a + 16) / 116, 3)), Math.pow(i / 100, 1 / 3));
    return [
      (e =
        e / 95.047 <= 0.008856
          ? (95.047 * (o / 500 + a - 16 / 116)) / 7.787
          : 95.047 * Math.pow(o / 500 + a, 3)),
      i,
      (n =
        n / 108.883 <= 0.008859
          ? (108.883 * (a - t / 200 - 16 / 116)) / 7.787
          : 108.883 * Math.pow(a - t / 200, 3)),
    ];
  }
  function tt(t) {
    var e,
      i = t[0],
      n = t[1],
      t = t[2];
    return (
      (e = (360 * Math.atan2(t, n)) / 2 / Math.PI) < 0 && (e += 360),
      [i, Math.sqrt(n * n + t * t), e]
    );
  }
  function et(t) {
    return $(Q(t));
  }
  function it(t) {
    var e = t[0],
      i = t[1],
      t = (t[2] / 360) * 2 * Math.PI;
    return [e, i * Math.cos(t), i * Math.sin(t)];
  }
  function e(t) {
    return at[t];
  }
  var nt,
    at = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50],
    },
    ot = {};
  for (nt in at) ot[JSON.stringify(at[nt])] = nt;
  function rt() {
    return new ut();
  }
  for (var st in B) {
    rt[st + "Raw"] = (function (e) {
      return function (t) {
        return (
          "number" == typeof t && (t = Array.prototype.slice.call(arguments)),
          B[e](t)
        );
      };
    })(st);
    var lt = /(\w+)2(\w+)/.exec(st),
      dt = lt[1],
      lt = lt[2];
    (rt[dt] = rt[dt] || {})[lt] = rt[st] = (function (n) {
      return function (t) {
        "number" == typeof t && (t = Array.prototype.slice.call(arguments));
        var e = B[n](t);
        if ("string" != typeof e && void 0 !== e)
          for (var i = 0; i < e.length; i++) e[i] = Math.round(e[i]);
        return e;
      };
    })(st);
  }
  var ut = function () {
      this.convs = {};
    },
    ht =
      ((ut.prototype.routeSpace = function (t, e) {
        var i = e[0];
        return void 0 === i
          ? this.getValues(t)
          : ("number" == typeof i && (i = Array.prototype.slice.call(e)),
            this.setValues(t, i));
      }),
      (ut.prototype.setValues = function (t, e) {
        return (this.space = t), (this.convs = {}), (this.convs[t] = e), this;
      }),
      (ut.prototype.getValues = function (t) {
        var e,
          i,
          n = this.convs[t];
        return (
          n ||
            ((e = this.space),
            (i = this.convs[e]),
            (n = rt[e][t](i)),
            (this.convs[t] = n)),
          n
        );
      }),
      ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (e) {
        ut.prototype[e] = function (t) {
          return this.routeSpace(e, arguments);
        };
      }),
      rt),
    ct = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50],
    },
    i = {
      getRgba: ft,
      getHsla: gt,
      getRgb: function (t) {
        t = ft(t);
        return t && t.slice(0, 3);
      },
      getHsl: function (t) {
        t = gt(t);
        return t && t.slice(0, 3);
      },
      getHwb: pt,
      getAlpha: function (t) {
        var e = ft(t);
        return (e = (e = e || gt(t)) || pt(t)) ? e[3] : void 0;
      },
      hexString: function (t, e) {
        e = void 0 !== e && 3 === t.length ? e : t[3];
        return (
          "#" +
          xt(t[0]) +
          xt(t[1]) +
          xt(t[2]) +
          (0 <= e && e < 1 ? xt(Math.round(255 * e)) : "")
        );
      },
      rgbString: function (t, e) {
        return e < 1 || (t[3] && t[3] < 1)
          ? mt(t, e)
          : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
      },
      rgbaString: mt,
      percentString: function (t, e) {
        return e < 1 || (t[3] && t[3] < 1)
          ? bt(t, e)
          : "rgb(" +
              Math.round((t[0] / 255) * 100) +
              "%, " +
              Math.round((t[1] / 255) * 100) +
              "%, " +
              Math.round((t[2] / 255) * 100) +
              "%)";
      },
      percentaString: bt,
      hslString: function (t, e) {
        return e < 1 || (t[3] && t[3] < 1)
          ? vt(t, e)
          : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)";
      },
      hslaString: vt,
      hwbString: function (t, e) {
        return (
          void 0 === e && (e = void 0 !== t[3] ? t[3] : 1),
          "hwb(" +
            t[0] +
            ", " +
            t[1] +
            "%, " +
            t[2] +
            "%" +
            (void 0 !== e && 1 !== e ? ", " + e : "") +
            ")"
        );
      },
      keyword: function (t) {
        return kt[t.slice(0, 3)];
      },
    };
  function ft(t) {
    if (t) {
      var e = [0, 0, 0],
        i = 1,
        n = t.match(/^#([a-fA-F0-9]{3,4})$/i),
        a = "";
      if (n) {
        for (var a = (n = n[1])[3], o = 0; o < e.length; o++)
          e[o] = parseInt(n[o] + n[o], 16);
        a && (i = Math.round((parseInt(a + a, 16) / 255) * 100) / 100);
      } else if ((n = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i))) {
        for (a = n[2], n = n[1], o = 0; o < e.length; o++)
          e[o] = parseInt(n.slice(2 * o, 2 * o + 2), 16);
        a && (i = Math.round((parseInt(a, 16) / 255) * 100) / 100);
      } else if (
        (n = t.match(
          /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i
        ))
      ) {
        for (o = 0; o < e.length; o++) e[o] = parseInt(n[o + 1]);
        i = parseFloat(n[4]);
      } else if (
        (n = t.match(
          /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i
        ))
      ) {
        for (o = 0; o < e.length; o++)
          e[o] = Math.round(2.55 * parseFloat(n[o + 1]));
        i = parseFloat(n[4]);
      } else if ((n = t.match(/(\w+)/))) {
        if ("transparent" == n[1]) return [0, 0, 0, 0];
        if (!(e = ct[n[1]])) return;
      }
      for (o = 0; o < e.length; o++) e[o] = s(e[o], 0, 255);
      return (i = i || 0 == i ? s(i, 0, 1) : 1), (e[3] = i), e;
    }
  }
  function gt(t) {
    if (t) {
      var e,
        t = t.match(
          /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/
        );
      if (t)
        return (
          (e = parseFloat(t[4])),
          [
            s(parseInt(t[1]), 0, 360),
            s(parseFloat(t[2]), 0, 100),
            s(parseFloat(t[3]), 0, 100),
            s(isNaN(e) ? 1 : e, 0, 1),
          ]
        );
    }
  }
  function pt(t) {
    if (t) {
      var e,
        t = t.match(
          /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/
        );
      if (t)
        return (
          (e = parseFloat(t[4])),
          [
            s(parseInt(t[1]), 0, 360),
            s(parseFloat(t[2]), 0, 100),
            s(parseFloat(t[3]), 0, 100),
            s(isNaN(e) ? 1 : e, 0, 1),
          ]
        );
    }
  }
  function mt(t, e) {
    return (
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1),
      "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")"
    );
  }
  function bt(t, e) {
    return (
      "rgba(" +
      Math.round((t[0] / 255) * 100) +
      "%, " +
      Math.round((t[1] / 255) * 100) +
      "%, " +
      Math.round((t[2] / 255) * 100) +
      "%, " +
      (e || t[3] || 1) +
      ")"
    );
  }
  function vt(t, e) {
    return (
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1),
      "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")"
    );
  }
  function s(t, e, i) {
    return Math.min(Math.max(e, t), i);
  }
  function xt(t) {
    t = t.toString(16).toUpperCase();
    return t.length < 2 ? "0" + t : t;
  }
  var yt,
    kt = {};
  for (yt in ct) kt[ct[yt]] = yt;
  function l(t) {
    return t instanceof l
      ? t
      : this instanceof l
      ? ((this.valid = !1),
        (this.values = {
          rgb: [0, 0, 0],
          hsl: [0, 0, 0],
          hsv: [0, 0, 0],
          hwb: [0, 0, 0],
          cmyk: [0, 0, 0, 0],
          alpha: 1,
        }),
        void ("string" == typeof t
          ? (e = i.getRgba(t))
            ? this.setValues("rgb", e)
            : (e = i.getHsla(t))
            ? this.setValues("hsl", e)
            : (e = i.getHwb(t)) && this.setValues("hwb", e)
          : "object" == typeof t &&
            (void 0 !== (e = t).r || void 0 !== e.red
              ? this.setValues("rgb", e)
              : void 0 !== e.l || void 0 !== e.lightness
              ? this.setValues("hsl", e)
              : void 0 !== e.v || void 0 !== e.value
              ? this.setValues("hsv", e)
              : void 0 !== e.w || void 0 !== e.whiteness
              ? this.setValues("hwb", e)
              : (void 0 === e.c && void 0 === e.cyan) ||
                this.setValues("cmyk", e))))
      : new l(t);
    var e;
  }
  ((l.prototype = {
    isValid: function () {
      return this.valid;
    },
    rgb: function () {
      return this.setSpace("rgb", arguments);
    },
    hsl: function () {
      return this.setSpace("hsl", arguments);
    },
    hsv: function () {
      return this.setSpace("hsv", arguments);
    },
    hwb: function () {
      return this.setSpace("hwb", arguments);
    },
    cmyk: function () {
      return this.setSpace("cmyk", arguments);
    },
    rgbArray: function () {
      return this.values.rgb;
    },
    hslArray: function () {
      return this.values.hsl;
    },
    hsvArray: function () {
      return this.values.hsv;
    },
    hwbArray: function () {
      var t = this.values;
      return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb;
    },
    cmykArray: function () {
      return this.values.cmyk;
    },
    rgbaArray: function () {
      var t = this.values;
      return t.rgb.concat([t.alpha]);
    },
    hslaArray: function () {
      var t = this.values;
      return t.hsl.concat([t.alpha]);
    },
    alpha: function (t) {
      return void 0 === t
        ? this.values.alpha
        : (this.setValues("alpha", t), this);
    },
    red: function (t) {
      return this.setChannel("rgb", 0, t);
    },
    green: function (t) {
      return this.setChannel("rgb", 1, t);
    },
    blue: function (t) {
      return this.setChannel("rgb", 2, t);
    },
    hue: function (t) {
      return (
        (t = t && ((t %= 360) < 0 ? 360 + t : t)), this.setChannel("hsl", 0, t)
      );
    },
    saturation: function (t) {
      return this.setChannel("hsl", 1, t);
    },
    lightness: function (t) {
      return this.setChannel("hsl", 2, t);
    },
    saturationv: function (t) {
      return this.setChannel("hsv", 1, t);
    },
    whiteness: function (t) {
      return this.setChannel("hwb", 1, t);
    },
    blackness: function (t) {
      return this.setChannel("hwb", 2, t);
    },
    value: function (t) {
      return this.setChannel("hsv", 2, t);
    },
    cyan: function (t) {
      return this.setChannel("cmyk", 0, t);
    },
    magenta: function (t) {
      return this.setChannel("cmyk", 1, t);
    },
    yellow: function (t) {
      return this.setChannel("cmyk", 2, t);
    },
    black: function (t) {
      return this.setChannel("cmyk", 3, t);
    },
    hexString: function () {
      return i.hexString(this.values.rgb);
    },
    rgbString: function () {
      return i.rgbString(this.values.rgb, this.values.alpha);
    },
    rgbaString: function () {
      return i.rgbaString(this.values.rgb, this.values.alpha);
    },
    percentString: function () {
      return i.percentString(this.values.rgb, this.values.alpha);
    },
    hslString: function () {
      return i.hslString(this.values.hsl, this.values.alpha);
    },
    hslaString: function () {
      return i.hslaString(this.values.hsl, this.values.alpha);
    },
    hwbString: function () {
      return i.hwbString(this.values.hwb, this.values.alpha);
    },
    keyword: function () {
      return i.keyword(this.values.rgb, this.values.alpha);
    },
    rgbNumber: function () {
      var t = this.values.rgb;
      return (t[0] << 16) | (t[1] << 8) | t[2];
    },
    luminosity: function () {
      for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) {
        var n = t[i] / 255;
        e[i] = n <= 0.03928 ? n / 12.92 : Math.pow((0.055 + n) / 1.055, 2.4);
      }
      return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
    },
    contrast: function (t) {
      var e = this.luminosity(),
        t = t.luminosity();
      return t < e ? (e + 0.05) / (t + 0.05) : (t + 0.05) / (e + 0.05);
    },
    level: function (t) {
      t = this.contrast(t);
      return 7.1 <= t ? "AAA" : 4.5 <= t ? "AA" : "";
    },
    dark: function () {
      var t = this.values.rgb;
      return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128;
    },
    light: function () {
      return !this.dark();
    },
    negate: function () {
      for (var t = [], e = 0; e < 3; e++) t[e] = 255 - this.values.rgb[e];
      return this.setValues("rgb", t), this;
    },
    lighten: function (t) {
      var e = this.values.hsl;
      return (e[2] += e[2] * t), this.setValues("hsl", e), this;
    },
    darken: function (t) {
      var e = this.values.hsl;
      return (e[2] -= e[2] * t), this.setValues("hsl", e), this;
    },
    saturate: function (t) {
      var e = this.values.hsl;
      return (e[1] += e[1] * t), this.setValues("hsl", e), this;
    },
    desaturate: function (t) {
      var e = this.values.hsl;
      return (e[1] -= e[1] * t), this.setValues("hsl", e), this;
    },
    whiten: function (t) {
      var e = this.values.hwb;
      return (e[1] += e[1] * t), this.setValues("hwb", e), this;
    },
    blacken: function (t) {
      var e = this.values.hwb;
      return (e[2] += e[2] * t), this.setValues("hwb", e), this;
    },
    greyscale: function () {
      var t = this.values.rgb,
        t = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2];
      return this.setValues("rgb", [t, t, t]), this;
    },
    clearer: function (t) {
      var e = this.values.alpha;
      return this.setValues("alpha", e - e * t), this;
    },
    opaquer: function (t) {
      var e = this.values.alpha;
      return this.setValues("alpha", e + e * t), this;
    },
    rotate: function (t) {
      var e = this.values.hsl,
        t = (e[0] + t) % 360;
      return (e[0] = t < 0 ? 360 + t : t), this.setValues("hsl", e), this;
    },
    mix: function (t, e) {
      var e = void 0 === e ? 0.5 : e,
        i = 2 * e - 1,
        n = this.alpha() - t.alpha(),
        i = (1 + (i * n == -1 ? i : (i + n) / (1 + i * n))) / 2,
        n = 1 - i;
      return this.rgb(
        i * this.red() + n * t.red(),
        i * this.green() + n * t.green(),
        i * this.blue() + n * t.blue()
      ).alpha(this.alpha() * e + t.alpha() * (1 - e));
    },
    toJSON: function () {
      return this.rgb();
    },
    clone: function () {
      var t,
        e,
        i,
        n = new l(),
        a = this.values,
        o = n.values;
      for (i in a)
        a.hasOwnProperty(i) &&
          ((t = a[i]),
          "[object Array]" === (e = {}.toString.call(t))
            ? (o[i] = t.slice(0))
            : "[object Number]" === e
            ? (o[i] = t)
            : console.error("unexpected color value:", t));
      return n;
    },
  }).spaces = {
    rgb: ["red", "green", "blue"],
    hsl: ["hue", "saturation", "lightness"],
    hsv: ["hue", "saturation", "value"],
    hwb: ["hue", "whiteness", "blackness"],
    cmyk: ["cyan", "magenta", "yellow", "black"],
  }),
    (l.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100],
    }),
    (l.prototype.getValues = function (t) {
      for (var e = this.values, i = {}, n = 0; n < t.length; n++)
        i[t.charAt(n)] = e[t][n];
      return 1 !== e.alpha && (i.a = e.alpha), i;
    }),
    (l.prototype.setValues = function (t, e) {
      var i,
        n,
        a = this.values,
        o = this.spaces,
        r = this.maxes,
        s = 1;
      if (((this.valid = !0), "alpha" === t)) s = e;
      else if (e.length) (a[t] = e.slice(0, t.length)), (s = e[t.length]);
      else if (void 0 !== e[t.charAt(0)]) {
        for (d = 0; d < t.length; d++) a[t][d] = e[t.charAt(d)];
        s = e.a;
      } else if (void 0 !== e[o[t][0]]) {
        for (var l = o[t], d = 0; d < t.length; d++) a[t][d] = e[l[d]];
        s = e.alpha;
      }
      if (
        ((a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s))),
        "alpha" === t)
      )
        return !1;
      for (d = 0; d < t.length; d++)
        (i = Math.max(0, Math.min(r[t][d], a[t][d]))),
          (a[t][d] = Math.round(i));
      for (n in o) n !== t && (a[n] = ht[t][n](a[t]));
      return !0;
    }),
    (l.prototype.setSpace = function (t, e) {
      var i = e[0];
      return void 0 === i
        ? this.getValues(t)
        : ("number" == typeof i && (i = Array.prototype.slice.call(e)),
          this.setValues(t, i),
          this);
    }),
    (l.prototype.setChannel = function (t, e, i) {
      var n = this.values[t];
      return void 0 === i
        ? n[e]
        : (i === n[e] || ((n[e] = i), this.setValues(t, n)), this);
    }),
    "undefined" != typeof window && (window.Color = l);
  function Mt(t) {
    q.extend(this, t), this.initialize.apply(this, arguments);
  }
  var wt,
    _t = l,
    u = {
      noop: function () {},
      uid:
        ((wt = 0),
        function () {
          return wt++;
        }),
      isNullOrUndef: function (t) {
        return null == t;
      },
      isArray: function (t) {
        return (
          !(!Array.isArray || !Array.isArray(t)) ||
          ("[object" === (t = Object.prototype.toString.call(t)).substr(0, 7) &&
            "Array]" === t.substr(-6))
        );
      },
      isObject: function (t) {
        return (
          null !== t && "[object Object]" === Object.prototype.toString.call(t)
        );
      },
      isFinite: function (t) {
        return ("number" == typeof t || t instanceof Number) && isFinite(t);
      },
      valueOrDefault: function (t, e) {
        return void 0 === t ? e : t;
      },
      valueAtIndexOrDefault: function (t, e, i) {
        return u.valueOrDefault(u.isArray(t) ? t[e] : t, i);
      },
      callback: function (t, e, i) {
        if (t && "function" == typeof t.call) return t.apply(i, e);
      },
      each: function (t, e, i, n) {
        var a, o, r;
        if (u.isArray(t))
          if (((o = t.length), n))
            for (a = o - 1; 0 <= a; a--) e.call(i, t[a], a);
          else for (a = 0; a < o; a++) e.call(i, t[a], a);
        else if (u.isObject(t))
          for (o = (r = Object.keys(t)).length, a = 0; a < o; a++)
            e.call(i, t[r[a]], r[a]);
      },
      arrayEquals: function (t, e) {
        var i, n, a, o;
        if (!t || !e || t.length !== e.length) return !1;
        for (i = 0, n = t.length; i < n; ++i)
          if (
            ((a = t[i]), (o = e[i]), a instanceof Array && o instanceof Array)
          ) {
            if (!u.arrayEquals(a, o)) return !1;
          } else if (a !== o) return !1;
        return !0;
      },
      clone: function (t) {
        if (u.isArray(t)) return t.map(u.clone);
        if (u.isObject(t)) {
          for (var e = {}, i = Object.keys(t), n = i.length, a = 0; a < n; ++a)
            e[i[a]] = u.clone(t[i[a]]);
          return e;
        }
        return t;
      },
      _merger: function (t, e, i, n) {
        var a = e[t],
          i = i[t];
        u.isObject(a) && u.isObject(i) ? u.merge(a, i, n) : (e[t] = u.clone(i));
      },
      _mergerIf: function (t, e, i) {
        var n = e[t],
          i = i[t];
        u.isObject(n) && u.isObject(i)
          ? u.mergeIf(n, i)
          : e.hasOwnProperty(t) || (e[t] = u.clone(i));
      },
      merge: function (t, e, i) {
        var n,
          a,
          o,
          r,
          s,
          l = u.isArray(e) ? e : [e],
          d = l.length;
        if (u.isObject(t))
          for (n = (i = i || {}).merger || u._merger, a = 0; a < d; ++a)
            if (((e = l[a]), u.isObject(e)))
              for (s = 0, r = (o = Object.keys(e)).length; s < r; ++s)
                n(o[s], t, e, i);
        return t;
      },
      mergeIf: function (t, e) {
        return u.merge(t, e, { merger: u._mergerIf });
      },
      extend: function (i) {
        for (
          var t = function (t, e) {
              i[e] = t;
            },
            e = 1,
            n = arguments.length;
          e < n;
          ++e
        )
          u.each(arguments[e], t);
        return i;
      },
      inherits: function (t) {
        function e() {
          this.constructor = n;
        }
        var i = this,
          n =
            t && t.hasOwnProperty("constructor")
              ? t.constructor
              : function () {
                  return i.apply(this, arguments);
                };
        return (
          (e.prototype = i.prototype),
          (n.prototype = new e()),
          (n.extend = u.inherits),
          t && u.extend(n.prototype, t),
          (n.__super__ = i.prototype),
          n
        );
      },
    },
    d = u,
    Ct =
      ((u.callCallback = u.callback),
      (u.indexOf = function (t, e, i) {
        return Array.prototype.indexOf.call(t, e, i);
      }),
      (u.getValueOrDefault = u.valueOrDefault),
      (u.getValueAtIndexOrDefault = u.valueAtIndexOrDefault),
      {
        linear: function (t) {
          return t;
        },
        easeInQuad: function (t) {
          return t * t;
        },
        easeOutQuad: function (t) {
          return -t * (t - 2);
        },
        easeInOutQuad: function (t) {
          return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
        },
        easeInCubic: function (t) {
          return t * t * t;
        },
        easeOutCubic: function (t) {
          return --t * t * t + 1;
        },
        easeInOutCubic: function (t) {
          return (t /= 0.5) < 1
            ? 0.5 * t * t * t
            : 0.5 * ((t -= 2) * t * t + 2);
        },
        easeInQuart: function (t) {
          return t * t * t * t;
        },
        easeOutQuart: function (t) {
          return -(--t * t * t * t - 1);
        },
        easeInOutQuart: function (t) {
          return (t /= 0.5) < 1
            ? 0.5 * t * t * t * t
            : -0.5 * ((t -= 2) * t * t * t - 2);
        },
        easeInQuint: function (t) {
          return t * t * t * t * t;
        },
        easeOutQuint: function (t) {
          return --t * t * t * t * t + 1;
        },
        easeInOutQuint: function (t) {
          return (t /= 0.5) < 1
            ? 0.5 * t * t * t * t * t
            : 0.5 * ((t -= 2) * t * t * t * t + 2);
        },
        easeInSine: function (t) {
          return 1 - Math.cos(t * (Math.PI / 2));
        },
        easeOutSine: function (t) {
          return Math.sin(t * (Math.PI / 2));
        },
        easeInOutSine: function (t) {
          return -0.5 * (Math.cos(Math.PI * t) - 1);
        },
        easeInExpo: function (t) {
          return 0 === t ? 0 : Math.pow(2, 10 * (t - 1));
        },
        easeOutExpo: function (t) {
          return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
        },
        easeInOutExpo: function (t) {
          return 0 === t
            ? 0
            : 1 === t
            ? 1
            : (t /= 0.5) < 1
            ? 0.5 * Math.pow(2, 10 * (t - 1))
            : 0.5 * (2 - Math.pow(2, -10 * --t));
        },
        easeInCirc: function (t) {
          return 1 <= t ? t : -(Math.sqrt(1 - t * t) - 1);
        },
        easeOutCirc: function (t) {
          return Math.sqrt(1 - --t * t);
        },
        easeInOutCirc: function (t) {
          return (t /= 0.5) < 1
            ? -0.5 * (Math.sqrt(1 - t * t) - 1)
            : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
        },
        easeInElastic: function (t) {
          var e = 1.70158,
            i = 0,
            n = 1;
          return 0 === t
            ? 0
            : 1 === t
            ? 1
            : ((i = i || 0.3),
              (e =
                n < 1
                  ? ((n = 1), i / 4)
                  : (i / (2 * Math.PI)) * Math.asin(1 / n)),
              -n *
                Math.pow(2, 10 * --t) *
                Math.sin(((t - e) * (2 * Math.PI)) / i));
        },
        easeOutElastic: function (t) {
          var e = 1.70158,
            i = 0,
            n = 1;
          return 0 === t
            ? 0
            : 1 === t
            ? 1
            : ((i = i || 0.3),
              (e =
                n < 1
                  ? ((n = 1), i / 4)
                  : (i / (2 * Math.PI)) * Math.asin(1 / n)),
              n *
                Math.pow(2, -10 * t) *
                Math.sin(((t - e) * (2 * Math.PI)) / i) +
                1);
        },
        easeInOutElastic: function (t) {
          var e = 1.70158,
            i = 0,
            n = 1;
          return 0 === t
            ? 0
            : 2 == (t /= 0.5)
            ? 1
            : ((i = i || 0.45),
              (e =
                n < 1
                  ? ((n = 1), i / 4)
                  : (i / (2 * Math.PI)) * Math.asin(1 / n)),
              t < 1
                ? n *
                  Math.pow(2, 10 * --t) *
                  Math.sin(((t - e) * (2 * Math.PI)) / i) *
                  -0.5
                : n *
                    Math.pow(2, -10 * --t) *
                    Math.sin(((t - e) * (2 * Math.PI)) / i) *
                    0.5 +
                  1);
        },
        easeInBack: function (t) {
          return t * t * (2.70158 * t - 1.70158);
        },
        easeOutBack: function (t) {
          return --t * t * (2.70158 * t + 1.70158) + 1;
        },
        easeInOutBack: function (t) {
          var e = 1.70158;
          return (t /= 0.5) < 1
            ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5
            : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
        },
        easeInBounce: function (t) {
          return 1 - Ct.easeOutBounce(1 - t);
        },
        easeOutBounce: function (t) {
          return t < 1 / 2.75
            ? 7.5625 * t * t
            : t < 2 / 2.75
            ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
            : t < 2.5 / 2.75
            ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
            : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        },
        easeInOutBounce: function (t) {
          return t < 0.5
            ? 0.5 * Ct.easeInBounce(2 * t)
            : 0.5 * Ct.easeOutBounce(2 * t - 1) + 0.5;
        },
      }),
    t = { effects: Ct },
    c = ((d.easingEffects = Ct), Math.PI),
    St = c / 180,
    Pt = 2 * c,
    f = c / 2,
    It = c / 4,
    At = (2 * c) / 3,
    Dt = {
      clear: function (t) {
        t.ctx.clearRect(0, 0, t.width, t.height);
      },
      roundedRect: function (t, e, i, n, a, o) {
        var r, s, l, d;
        o
          ? ((r = e + (o = Math.min(o, a / 2, n / 2))),
            (l = e + n - o),
            (d = i + a - o),
            t.moveTo(e, (s = i + o)),
            r < l && s < d
              ? (t.arc(r, s, o, -c, -f),
                t.arc(l, s, o, -f, 0),
                t.arc(l, d, o, 0, f),
                t.arc(r, d, o, f, c))
              : r < l
              ? (t.moveTo(r, i),
                t.arc(l, s, o, -f, f),
                t.arc(r, s, o, f, c + f))
              : s < d
              ? (t.arc(r, s, o, -c, 0), t.arc(r, d, o, 0, c))
              : t.arc(r, s, o, -c, c),
            t.closePath(),
            t.moveTo(e, i))
          : t.rect(e, i, n, a);
      },
      drawPoint: function (t, e, i, n, a, o) {
        var r,
          s,
          l,
          d,
          u,
          h = (o || 0) * St;
        if (
          !e ||
          "object" != typeof e ||
          ("[object HTMLImageElement]" !== (r = e.toString()) &&
            "[object HTMLCanvasElement]" !== r)
        ) {
          if (!(isNaN(i) || i <= 0)) {
            switch ((t.beginPath(), e)) {
              default:
                t.arc(n, a, i, 0, Pt), t.closePath();
                break;
              case "triangle":
                t.moveTo(n + Math.sin(h) * i, a - Math.cos(h) * i),
                  (h += At),
                  t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i),
                  (h += At),
                  t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i),
                  t.closePath();
                break;
              case "rectRounded":
                (d = i - (u = 0.516 * i)),
                  (s = Math.cos(h + It) * d),
                  (l = Math.sin(h + It) * d),
                  t.arc(n - s, a - l, u, h - c, h - f),
                  t.arc(n + l, a - s, u, h - f, h),
                  t.arc(n + s, a + l, u, h, h + f),
                  t.arc(n - l, a + s, u, h + f, h + c),
                  t.closePath();
                break;
              case "rect":
                if (!o) {
                  (d = Math.SQRT1_2 * i), t.rect(n - d, a - d, 2 * d, 2 * d);
                  break;
                }
                h += It;
              case "rectRot":
                (s = Math.cos(h) * i),
                  (l = Math.sin(h) * i),
                  t.moveTo(n - s, a - l),
                  t.lineTo(n + l, a - s),
                  t.lineTo(n + s, a + l),
                  t.lineTo(n - l, a + s),
                  t.closePath();
                break;
              case "crossRot":
                h += It;
              case "cross":
                (s = Math.cos(h) * i),
                  (l = Math.sin(h) * i),
                  t.moveTo(n - s, a - l),
                  t.lineTo(n + s, a + l),
                  t.moveTo(n + l, a - s),
                  t.lineTo(n - l, a + s);
                break;
              case "star":
                (s = Math.cos(h) * i),
                  (l = Math.sin(h) * i),
                  t.moveTo(n - s, a - l),
                  t.lineTo(n + s, a + l),
                  t.moveTo(n + l, a - s),
                  t.lineTo(n - l, a + s),
                  (h += It),
                  (s = Math.cos(h) * i),
                  (l = Math.sin(h) * i),
                  t.moveTo(n - s, a - l),
                  t.lineTo(n + s, a + l),
                  t.moveTo(n + l, a - s),
                  t.lineTo(n - l, a + s);
                break;
              case "line":
                (s = Math.cos(h) * i),
                  (l = Math.sin(h) * i),
                  t.moveTo(n - s, a - l),
                  t.lineTo(n + s, a + l);
                break;
              case "dash":
                t.moveTo(n, a),
                  t.lineTo(n + Math.cos(h) * i, a + Math.sin(h) * i);
            }
            t.fill(), t.stroke();
          }
        } else
          t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height);
      },
      _isPointInArea: function (t, e) {
        return (
          t.x > e.left - 1e-6 &&
          t.x < e.right + 1e-6 &&
          t.y > e.top - 1e-6 &&
          t.y < e.bottom + 1e-6
        );
      },
      clipArea: function (t, e) {
        t.save(),
          t.beginPath(),
          t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
          t.clip();
      },
      unclipArea: function (t) {
        t.restore();
      },
      lineTo: function (t, e, i, n) {
        var a,
          o = i.steppedLine;
        o
          ? ("middle" === o
              ? ((a = (e.x + i.x) / 2),
                t.lineTo(a, (n ? i : e).y),
                t.lineTo(a, (n ? e : i).y))
              : ("after" === o && !n) || ("after" !== o && n)
              ? t.lineTo(e.x, i.y)
              : t.lineTo(i.x, e.y),
            t.lineTo(i.x, i.y))
          : i.tension
          ? t.bezierCurveTo(
              n ? e.controlPointPreviousX : e.controlPointNextX,
              n ? e.controlPointPreviousY : e.controlPointNextY,
              n ? i.controlPointNextX : i.controlPointPreviousX,
              n ? i.controlPointNextY : i.controlPointPreviousY,
              i.x,
              i.y
            )
          : t.lineTo(i.x, i.y);
      },
    },
    a = Dt,
    o =
      ((d.clear = Dt.clear),
      (d.drawRoundedRectangle = function (t) {
        t.beginPath(), Dt.roundedRect.apply(Dt, arguments);
      }),
      {
        _set: function (t, e) {
          return d.merge(this[t] || (this[t] = {}), e);
        },
      }),
    j =
      (o._set("global", {
        defaultColor: "rgba(0,0,0,0.1)",
        defaultFontColor: "#666",
        defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        defaultFontSize: 12,
        defaultFontStyle: "normal",
        defaultLineHeight: 1.2,
        showLines: !0,
      }),
      o),
    Tt = d.valueOrDefault,
    q = d,
    o = a,
    a = {
      toLineHeight: function (t, e) {
        var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        if (!i || "normal" === i[1]) return 1.2 * e;
        switch (((t = +i[2]), i[3])) {
          case "px":
            return t;
          case "%":
            t /= 100;
        }
        return e * t;
      },
      toPadding: function (t) {
        var e, i, n, a;
        return (
          d.isObject(t)
            ? ((e = +t.top || 0),
              (i = +t.right || 0),
              (n = +t.bottom || 0),
              (a = +t.left || 0))
            : (e = i = n = a = +t || 0),
          { top: e, right: i, bottom: n, left: a, height: e + n, width: a + i }
        );
      },
      _parseFont: function (t) {
        var e = j.global,
          i = Tt(t.fontSize, e.defaultFontSize),
          i = {
            family: Tt(t.fontFamily, e.defaultFontFamily),
            lineHeight: d.options.toLineHeight(
              Tt(t.lineHeight, e.defaultLineHeight),
              i
            ),
            size: i,
            style: Tt(t.fontStyle, e.defaultFontStyle),
            weight: null,
            string: "",
          };
        return (
          (i.string =
            !(t = i) || d.isNullOrUndef(t.size) || d.isNullOrUndef(t.family)
              ? null
              : (t.style ? t.style + " " : "") +
                (t.weight ? t.weight + " " : "") +
                t.size +
                "px " +
                t.family),
          i
        );
      },
      resolve: function (t, e, i) {
        for (var n, a = 0, o = t.length; a < o; ++a)
          if (
            void 0 !== (n = t[a]) &&
            (void 0 !== e && "function" == typeof n && (n = n(e)),
            void 0 !== (n = void 0 !== i && d.isArray(n) ? n[i] : n))
          )
            return n;
      },
    },
    t =
      ((q.easing = t),
      (q.canvas = o),
      (q.options = a),
      q.extend(Mt.prototype, {
        initialize: function () {
          this.hidden = !1;
        },
        pivot: function () {
          var t = this;
          return t._view || (t._view = q.clone(t._model)), (t._start = {}), t;
        },
        transition: function (t) {
          var e = this,
            i = e._model,
            n = e._start,
            a = e._view;
          if (i && 1 !== t) {
            for (
              var a = a || (e._view = {}),
                n,
                o = (n = n || (e._start = {})),
                r = a,
                s = i,
                l = t,
                d,
                u,
                h,
                c,
                f,
                g = Object.keys(s),
                p = 0,
                m = g.length;
              p < m;
              ++p
            )
              if (
                ((h = s[(d = g[p])]),
                r.hasOwnProperty(d) || (r[d] = h),
                (c = r[d]) !== h && "_" !== d[0])
              ) {
                if (
                  (o.hasOwnProperty(d) || (o[d] = c),
                  (c = typeof h) == typeof (u = o[d]))
                )
                  if ("string" == c) {
                    if ((c = _t(u)).valid && (f = _t(h)).valid) {
                      r[d] = f.mix(c, l).rgbString();
                      continue;
                    }
                  } else if (q.isFinite(u) && q.isFinite(h)) {
                    r[d] = u + (h - u) * l;
                    continue;
                  }
                r[d] = h;
              }
          } else (e._view = i), (e._start = null);
          return e;
        },
        tooltipPosition: function () {
          return { x: this._model.x, y: this._model.y };
        },
        hasValue: function () {
          return q.isNumber(this._model.x) && q.isNumber(this._model.y);
        },
      }),
      (Mt.extend = q.inherits),
      Mt),
    o = t.extend({
      chart: null,
      currentStep: 0,
      numSteps: 60,
      easing: "",
      render: null,
      onAnimationProgress: null,
      onAnimationComplete: null,
    }),
    Ft = o,
    Lt =
      (Object.defineProperty(o.prototype, "animationObject", {
        get: function () {
          return this;
        },
      }),
      Object.defineProperty(o.prototype, "chartInstance", {
        get: function () {
          return this.chart;
        },
        set: function (t) {
          this.chart = t;
        },
      }),
      j._set("global", {
        animation: {
          duration: 1e3,
          easing: "easeOutQuart",
          onProgress: q.noop,
          onComplete: q.noop,
        },
      }),
      {
        animations: [],
        request: null,
        addAnimation: function (t, e, i, n) {
          var a,
            o,
            r = this.animations;
          for (
            e.chart = t,
              e.startTime = Date.now(),
              e.duration = i,
              n || (t.animating = !0),
              a = 0,
              o = r.length;
            a < o;
            ++a
          )
            if (r[a].chart === t) return void (r[a] = e);
          r.push(e), 1 === r.length && this.requestAnimationFrame();
        },
        cancelAnimation: function (e) {
          var t = q.findIndex(this.animations, function (t) {
            return t.chart === e;
          });
          -1 !== t && (this.animations.splice(t, 1), (e.animating = !1));
        },
        requestAnimationFrame: function () {
          var t = this;
          null === t.request &&
            (t.request = q.requestAnimFrame.call(window, function () {
              (t.request = null), t.startDigest();
            }));
        },
        startDigest: function () {
          this.advance(),
            0 < this.animations.length && this.requestAnimationFrame();
        },
        advance: function () {
          for (var t, e, i, n, a = this.animations, o = 0; o < a.length; )
            (e = (t = a[o]).chart),
              (i = t.numSteps),
              (n =
                Math.floor(((Date.now() - t.startTime) / t.duration) * i) + 1),
              (t.currentStep = Math.min(n, i)),
              q.callback(t.render, [e, t], e),
              q.callback(t.onAnimationProgress, [t], e),
              t.currentStep >= i
                ? (q.callback(t.onAnimationComplete, [t], e),
                  (e.animating = !1),
                  a.splice(o, 1))
                : ++o;
        },
      }),
    Rt = q.options.resolve,
    Ot = ["push", "pop", "shift", "splice", "unshift"];
  function zt(e, t) {
    var i = e._chartjs;
    i &&
      (-1 !== (t = (i = i.listeners).indexOf(t)) && i.splice(t, 1),
      0 < i.length ||
        (Ot.forEach(function (t) {
          delete e[t];
        }),
        delete e._chartjs));
  }
  function Bt(t, e) {
    this.initialize(t, e);
  }
  q.extend(Bt.prototype, {
    datasetElementType: null,
    dataElementType: null,
    initialize: function (t, e) {
      (this.chart = t), (this.index = e), this.linkScales(), this.addElements();
    },
    updateIndex: function (t) {
      this.index = t;
    },
    linkScales: function () {
      var t = this,
        e = t.getMeta(),
        i = t.getDataset();
      (null !== e.xAxisID && e.xAxisID in t.chart.scales) ||
        (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id),
        (null !== e.yAxisID && e.yAxisID in t.chart.scales) ||
          (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id);
    },
    getDataset: function () {
      return this.chart.data.datasets[this.index];
    },
    getMeta: function () {
      return this.chart.getDatasetMeta(this.index);
    },
    getScaleForId: function (t) {
      return this.chart.scales[t];
    },
    _getValueScaleId: function () {
      return this.getMeta().yAxisID;
    },
    _getIndexScaleId: function () {
      return this.getMeta().xAxisID;
    },
    _getValueScale: function () {
      return this.getScaleForId(this._getValueScaleId());
    },
    _getIndexScale: function () {
      return this.getScaleForId(this._getIndexScaleId());
    },
    reset: function () {
      this.update(!0);
    },
    destroy: function () {
      this._data && zt(this._data, this);
    },
    createMetaDataset: function () {
      var t = this.datasetElementType;
      return t && new t({ _chart: this.chart, _datasetIndex: this.index });
    },
    createMetaData: function (t) {
      var e = this.dataElementType;
      return (
        e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t })
      );
    },
    addElements: function () {
      for (
        var t = this.getMeta(),
          e = this.getDataset().data || [],
          i = t.data,
          n = 0,
          a = e.length;
        n < a;
        ++n
      )
        i[n] = i[n] || this.createMetaData(n);
      t.dataset = t.dataset || this.createMetaDataset();
    },
    addElementAndReset: function (t) {
      var e = this.createMetaData(t);
      this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0);
    },
    buildOrUpdateElements: function () {
      var a,
        t,
        e = this,
        i = e.getDataset(),
        i = i.data || (i.data = []);
      e._data !== i &&
        (e._data && zt(e._data, e),
        i &&
          Object.isExtensible(i) &&
          ((t = e),
          (a = i)._chartjs
            ? a._chartjs.listeners.push(t)
            : (Object.defineProperty(a, "_chartjs", {
                configurable: !0,
                enumerable: !1,
                value: { listeners: [t] },
              }),
              Ot.forEach(function (t) {
                var i = "onData" + t.charAt(0).toUpperCase() + t.slice(1),
                  n = a[t];
                Object.defineProperty(a, t, {
                  configurable: !0,
                  enumerable: !1,
                  value: function () {
                    var e = Array.prototype.slice.call(arguments),
                      t = n.apply(this, e);
                    return (
                      q.each(a._chartjs.listeners, function (t) {
                        "function" == typeof t[i] && t[i].apply(t, e);
                      }),
                      t
                    );
                  },
                });
              }))),
        (e._data = i)),
        e.resyncElements();
    },
    update: q.noop,
    transition: function (t) {
      for (
        var e = this.getMeta(), i = e.data || [], n = i.length, a = 0;
        a < n;
        ++a
      )
        i[a].transition(t);
      e.dataset && e.dataset.transition(t);
    },
    draw: function () {
      var t = this.getMeta(),
        e = t.data || [],
        i = e.length,
        n = 0;
      for (t.dataset && t.dataset.draw(); n < i; ++n) e[n].draw();
    },
    removeHoverStyle: function (t) {
      q.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle;
    },
    setHoverStyle: function (t) {
      var e = this.chart.data.datasets[t._datasetIndex],
        i = t._index,
        n = t.custom || {},
        a = t._model,
        o = q.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: a.backgroundColor,
        borderColor: a.borderColor,
        borderWidth: a.borderWidth,
      }),
        (a.backgroundColor = Rt(
          [
            n.hoverBackgroundColor,
            e.hoverBackgroundColor,
            o(a.backgroundColor),
          ],
          void 0,
          i
        )),
        (a.borderColor = Rt(
          [n.hoverBorderColor, e.hoverBorderColor, o(a.borderColor)],
          void 0,
          i
        )),
        (a.borderWidth = Rt(
          [n.hoverBorderWidth, e.hoverBorderWidth, a.borderWidth],
          void 0,
          i
        ));
    },
    resyncElements: function () {
      var t = this.getMeta(),
        e = this.getDataset().data,
        i = t.data.length,
        e = e.length;
      e < i ? t.data.splice(e, i - e) : i < e && this.insertElements(i, e - i);
    },
    insertElements: function (t, e) {
      for (var i = 0; i < e; ++i) this.addElementAndReset(t + i);
    },
    onDataPush: function () {
      var t = arguments.length;
      this.insertElements(this.getDataset().data.length - t, t);
    },
    onDataPop: function () {
      this.getMeta().data.pop();
    },
    onDataShift: function () {
      this.getMeta().data.shift();
    },
    onDataSplice: function (t, e) {
      this.getMeta().data.splice(t, e),
        this.insertElements(t, arguments.length - 2);
    },
    onDataUnshift: function () {
      this.insertElements(0, arguments.length);
    },
  }),
    (Bt.extend = q.inherits);
  var h = Bt,
    a =
      (j._set("global", {
        elements: {
          arc: {
            backgroundColor: j.global.defaultColor,
            borderColor: "#fff",
            borderWidth: 2,
            borderAlign: "center",
          },
        },
      }),
      t.extend({
        inLabelRange: function (t) {
          var e = this._view;
          return (
            !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2)
          );
        },
        inRange: function (t, e) {
          var i = this._view;
          if (i) {
            for (
              var t = q.getAngleFromPoint(i, { x: t, y: e }),
                n = t.angle,
                e = t.distance,
                a = i.startAngle,
                o = i.endAngle;
              o < a;

            )
              o += 2 * Math.PI;
            for (; o < n; ) n -= 2 * Math.PI;
            for (; n < a; ) n += 2 * Math.PI;
            t = e >= i.innerRadius && e <= i.outerRadius;
            return a <= n && n <= o && t;
          }
          return !1;
        },
        getCenterPoint: function () {
          var t = this._view,
            e = (t.startAngle + t.endAngle) / 2,
            i = (t.innerRadius + t.outerRadius) / 2;
          return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i };
        },
        getArea: function () {
          var t = this._view;
          return (
            Math.PI *
            ((t.endAngle - t.startAngle) / (2 * Math.PI)) *
            (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2))
          );
        },
        tooltipPosition: function () {
          var t = this._view,
            e = t.startAngle + (t.endAngle - t.startAngle) / 2,
            i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
          return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i };
        },
        draw: function () {
          var t,
            e = this._chart.ctx,
            i = this._view,
            n = i.startAngle,
            a = i.endAngle,
            o = "inner" === i.borderAlign ? 0.33 : 0;
          e.save(),
            e.beginPath(),
            e.arc(i.x, i.y, Math.max(i.outerRadius - o, 0), n, a),
            e.arc(i.x, i.y, i.innerRadius, a, n, !0),
            e.closePath(),
            (e.fillStyle = i.backgroundColor),
            e.fill(),
            i.borderWidth &&
              ("inner" === i.borderAlign
                ? (e.beginPath(),
                  (t = o / i.outerRadius),
                  e.arc(i.x, i.y, i.outerRadius, n - t, a + t),
                  i.innerRadius > o
                    ? ((t = o / i.innerRadius),
                      e.arc(i.x, i.y, i.innerRadius - o, a + t, n - t, !0))
                    : e.arc(i.x, i.y, o, a + Math.PI / 2, n - Math.PI / 2),
                  e.closePath(),
                  e.clip(),
                  e.beginPath(),
                  e.arc(i.x, i.y, i.outerRadius, n, a),
                  e.arc(i.x, i.y, i.innerRadius, a, n, !0),
                  e.closePath(),
                  (e.lineWidth = 2 * i.borderWidth),
                  (e.lineJoin = "round"))
                : ((e.lineWidth = i.borderWidth), (e.lineJoin = "bevel")),
              (e.strokeStyle = i.borderColor),
              e.stroke()),
            e.restore();
        },
      })),
    Nt = q.valueOrDefault,
    o = j.global.defaultColor,
    o =
      (j._set("global", {
        elements: {
          line: {
            tension: 0.4,
            backgroundColor: o,
            borderWidth: 3,
            borderColor: o,
            borderCapStyle: "butt",
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: "miter",
            capBezierPoints: !0,
            fill: !0,
          },
        },
      }),
      t.extend({
        draw: function () {
          var t,
            e,
            i,
            n,
            a = this._view,
            o = this._chart.ctx,
            r = a.spanGaps,
            s = this._children.slice(),
            l = j.global,
            d = l.elements.line,
            u = -1;
          for (
            this._loop && s.length && s.push(s[0]),
              o.save(),
              o.lineCap = a.borderCapStyle || d.borderCapStyle,
              o.setLineDash && o.setLineDash(a.borderDash || d.borderDash),
              o.lineDashOffset = Nt(a.borderDashOffset, d.borderDashOffset),
              o.lineJoin = a.borderJoinStyle || d.borderJoinStyle,
              o.lineWidth = Nt(a.borderWidth, d.borderWidth),
              o.strokeStyle = a.borderColor || l.defaultColor,
              o.beginPath(),
              u = -1,
              t = 0;
            t < s.length;
            ++t
          )
            (e = s[t]),
              (i = q.previousItem(s, t)),
              (n = e._view),
              0 === t
                ? n.skip || (o.moveTo(n.x, n.y), (u = t))
                : ((i = -1 === u ? i : s[u]),
                  n.skip ||
                    ((u !== t - 1 && !r) || -1 === u
                      ? o.moveTo(n.x, n.y)
                      : q.canvas.lineTo(o, i._view, e._view),
                    (u = t)));
          o.stroke(), o.restore();
        },
      })),
    Wt = q.valueOrDefault,
    p = j.global.defaultColor;
  function Vt(t) {
    var e = this._view;
    return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius;
  }
  j._set("global", {
    elements: {
      point: {
        radius: 3,
        pointStyle: "circle",
        backgroundColor: p,
        borderColor: p,
        borderWidth: 1,
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1,
      },
    },
  });
  var p = t.extend({
      inRange: function (t, e) {
        var i = this._view;
        return (
          !!i &&
          Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) <
            Math.pow(i.hitRadius + i.radius, 2)
        );
      },
      inLabelRange: Vt,
      inXRange: Vt,
      inYRange: function (t) {
        var e = this._view;
        return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius;
      },
      getCenterPoint: function () {
        var t = this._view;
        return { x: t.x, y: t.y };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var t = this._view;
        return { x: t.x, y: t.y, padding: t.radius + t.borderWidth };
      },
      draw: function (t) {
        var e = this._view,
          i = this._chart.ctx,
          n = e.pointStyle,
          a = e.rotation,
          o = e.radius,
          r = e.x,
          s = e.y,
          l = j.global,
          d = l.defaultColor;
        e.skip ||
          (void 0 !== t && !q.canvas._isPointInArea(e, t)) ||
          ((i.strokeStyle = e.borderColor || d),
          (i.lineWidth = Wt(e.borderWidth, l.elements.point.borderWidth)),
          (i.fillStyle = e.backgroundColor || d),
          q.canvas.drawPoint(i, n, o, r, s, a));
      },
    }),
    m = j.global.defaultColor;
  function Et(t) {
    return t && void 0 !== t.width;
  }
  function Ht(t) {
    var e,
      i,
      n,
      a,
      t = Et(t)
        ? ((a = t.width / 2),
          (e = t.x - a),
          (i = t.x + a),
          (n = Math.min(t.y, t.base)),
          Math.max(t.y, t.base))
        : ((a = t.height / 2),
          (e = Math.min(t.x, t.base)),
          (i = Math.max(t.x, t.base)),
          (n = t.y - a),
          t.y + a);
    return { left: e, top: n, right: i, bottom: t };
  }
  function jt(t, e, i) {
    return t === e ? i : t === i ? e : t;
  }
  function qt(t, e, i) {
    var n = null === e,
      a = null === i,
      t = !(!t || (n && a)) && Ht(t);
    return (
      t &&
      (n || (e >= t.left && e <= t.right)) &&
      (a || (i >= t.top && i <= t.bottom))
    );
  }
  j._set("global", {
    elements: {
      rectangle: {
        backgroundColor: m,
        borderColor: m,
        borderSkipped: "bottom",
        borderWidth: 0,
      },
    },
  });
  var m = t.extend({
      draw: function () {
        var t,
          e,
          i,
          n,
          a,
          o,
          r,
          s,
          l,
          d,
          u = this._chart.ctx,
          h = this._view,
          c =
            ((r = Ht((t = h))),
            (s = r.right - r.left),
            (l = r.bottom - r.top),
            (e = s / 2),
            (i = l / 2),
            (f = (t = t).borderWidth),
            (d = t.borderSkipped),
            (c = {}),
            d &&
              (t.horizontal
                ? t.base > t.x && (d = jt(d, "left", "right"))
                : t.base < t.y && (d = jt(d, "bottom", "top")),
              (c[d] = !0)),
            (t = c),
            q.isObject(f)
              ? ((g = +f.top || 0),
                (n = +f.right || 0),
                (a = +f.bottom || 0),
                (o = +f.left || 0))
              : (g = n = a = o = +f || 0),
            (d = {
              t: t.top || g < 0 ? 0 : i < g ? i : g,
              r: t.right || n < 0 ? 0 : e < n ? e : n,
              b: t.bottom || a < 0 ? 0 : i < a ? i : a,
              l: t.left || o < 0 ? 0 : e < o ? e : o,
            }),
            {
              outer: { x: r.left, y: r.top, w: s, h: l },
              inner: {
                x: r.left + d.l,
                y: r.top + d.t,
                w: s - d.l - d.r,
                h: l - d.t - d.b,
              },
            }),
          f = c.outer,
          g = c.inner;
        (u.fillStyle = h.backgroundColor),
          u.fillRect(f.x, f.y, f.w, f.h),
          (f.w === g.w && f.h === g.h) ||
            (u.save(),
            u.beginPath(),
            u.rect(f.x, f.y, f.w, f.h),
            u.clip(),
            (u.fillStyle = h.borderColor),
            u.rect(g.x, g.y, g.w, g.h),
            u.fill("evenodd"),
            u.restore());
      },
      height: function () {
        var t = this._view;
        return t.base - t.y;
      },
      inRange: function (t, e) {
        return qt(this._view, t, e);
      },
      inLabelRange: function (t, e) {
        var i = this._view;
        return Et(i) ? qt(i, t, null) : qt(i, null, e);
      },
      inXRange: function (t) {
        return qt(this._view, t, null);
      },
      inYRange: function (t) {
        return qt(this._view, null, t);
      },
      getCenterPoint: function () {
        var t,
          e = this._view,
          e = Et(e)
            ? ((t = e.x), (e.y + e.base) / 2)
            : ((t = (e.x + e.base) / 2), e.y);
        return { x: t, y: e };
      },
      getArea: function () {
        var t = this._view;
        return Et(t)
          ? t.width * Math.abs(t.y - t.base)
          : t.height * Math.abs(t.x - t.base);
      },
      tooltipPosition: function () {
        var t = this._view;
        return { x: t.x, y: t.y };
      },
    }),
    v = {},
    Yt =
      ((v.Arc = a),
      (v.Line = o),
      (v.Point = p),
      (v.Rectangle = m),
      q.options.resolve),
    a =
      (j._set("bar", {
        hover: { mode: "label" },
        scales: {
          xAxes: [
            {
              type: "category",
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              offset: !0,
              gridLines: { offsetGridLines: !0 },
            },
          ],
          yAxes: [{ type: "linear" }],
        },
      }),
      h.extend({
        dataElementType: v.Rectangle,
        initialize: function () {
          var t;
          h.prototype.initialize.apply(this, arguments),
            ((t = this.getMeta()).stack = this.getDataset().stack),
            (t.bar = !0);
        },
        update: function (t) {
          var e,
            i,
            n = this.getMeta().data;
          for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e)
            this.updateElement(n[e], e, t);
        },
        updateElement: function (t, e, i) {
          var n = this,
            a = n.getMeta(),
            o = n.getDataset(),
            r = n._resolveElementOptions(t, e);
          (t._xScale = n.getScaleForId(a.xAxisID)),
            (t._yScale = n.getScaleForId(a.yAxisID)),
            (t._datasetIndex = n.index),
            (t._index = e),
            (t._model = {
              backgroundColor: r.backgroundColor,
              borderColor: r.borderColor,
              borderSkipped: r.borderSkipped,
              borderWidth: r.borderWidth,
              datasetLabel: o.label,
              label: n.chart.data.labels[e],
            }),
            n._updateElementGeometry(t, e, i),
            t.pivot();
        },
        _updateElementGeometry: function (t, e, i) {
          var n = this,
            t = t._model,
            a = n._getValueScale(),
            o = a.getBasePixel(),
            a = a.isHorizontal(),
            r = n._ruler || n.getRuler(),
            s = n.calculateBarValuePixels(n.index, e),
            n = n.calculateBarIndexPixels(n.index, e, r);
          (t.horizontal = a),
            (t.base = i ? o : s.base),
            (t.x = a ? (i ? o : s.head) : n.center),
            (t.y = a ? n.center : i ? o : s.head),
            (t.height = a ? n.size : void 0),
            (t.width = a ? void 0 : n.size);
        },
        _getStacks: function (t) {
          for (
            var e,
              i = this.chart,
              n = this._getIndexScale().options.stacked,
              a = void 0 === t ? i.data.datasets.length : t + 1,
              o = [],
              r = 0;
            r < a;
            ++r
          )
            (e = i.getDatasetMeta(r)).bar &&
              i.isDatasetVisible(r) &&
              (!1 === n ||
                (!0 === n && -1 === o.indexOf(e.stack)) ||
                (void 0 === n &&
                  (void 0 === e.stack || -1 === o.indexOf(e.stack)))) &&
              o.push(e.stack);
          return o;
        },
        getStackCount: function () {
          return this._getStacks().length;
        },
        getStackIndex: function (t, e) {
          (t = this._getStacks(t)), (e = void 0 !== e ? t.indexOf(e) : -1);
          return -1 === e ? t.length - 1 : e;
        },
        getRuler: function () {
          for (
            var t = this._getIndexScale(),
              e = this.getStackCount(),
              i = this.index,
              n = t.isHorizontal(),
              a = n ? t.left : t.top,
              n = a + (n ? t.width : t.height),
              o = [],
              r = 0,
              s = this.getMeta().data.length;
            r < s;
            ++r
          )
            o.push(t.getPixelForValue(null, r, i));
          return {
            min: q.isNullOrUndef(t.options.barThickness)
              ? (function (t, e) {
                  for (
                    var i,
                      n,
                      a = t.isHorizontal() ? t.width : t.height,
                      o = t.getTicks(),
                      r = 1,
                      s = e.length;
                    r < s;
                    ++r
                  )
                    a = Math.min(a, Math.abs(e[r] - e[r - 1]));
                  for (r = 0, s = o.length; r < s; ++r)
                    (n = t.getPixelForTick(r)),
                      (a = 0 < r ? Math.min(a, n - i) : a),
                      (i = n);
                  return a;
                })(t, o)
              : -1,
            pixels: o,
            start: a,
            end: n,
            stackCount: e,
            scale: t,
          };
        },
        calculateBarValuePixels: function (t, e) {
          var i,
            n,
            a,
            o = this.chart,
            r = this.getMeta(),
            s = this._getValueScale(),
            l = s.isHorizontal(),
            d = o.data.datasets,
            u = +s.getRightValue(d[t].data[e]),
            h = s.options.minBarLength,
            c = s.options.stacked,
            f = r.stack,
            g = 0;
          if (c || (void 0 === c && void 0 !== f))
            for (i = 0; i < t; ++i)
              (n = o.getDatasetMeta(i)).bar &&
                n.stack === f &&
                n.controller._getValueScaleId() === s.id &&
                o.isDatasetVisible(i) &&
                ((n = +s.getRightValue(d[i].data[e])),
                (u < 0 && n < 0) || (0 <= u && 0 < n)) &&
                (g += n);
          return (
            (r = s.getPixelForValue(g)),
            (a = (c = s.getPixelForValue(g + u)) - r),
            void 0 !== h &&
              Math.abs(a) < h &&
              ((a = h), (c = (0 <= u && !l) || (u < 0 && l) ? r - h : r + h)),
            { size: a, base: r, head: c, center: c + a / 2 }
          );
        },
        calculateBarIndexPixels: function (t, e, i) {
          var n,
            a,
            o,
            r,
            s,
            l = i.scale.options,
            d =
              "flex" === l.barThickness
                ? ((a = l),
                  (o = (n = i).pixels),
                  (d = o[e]),
                  (r = 0 < e ? o[e - 1] : null),
                  (o = e < o.length - 1 ? o[e + 1] : null),
                  (s = a.categoryPercentage),
                  null === r &&
                    (r = d - (null === o ? n.end - n.start : o - d)),
                  null === o && (o = d + d - r),
                  (d = d - ((d - Math.min(r, o)) / 2) * s),
                  {
                    chunk: ((Math.abs(o - r) / 2) * s) / n.stackCount,
                    ratio: a.barPercentage,
                    start: d,
                  })
                : ((o = i),
                  (s = (r = l).barThickness),
                  (n = o.stackCount),
                  (a = o.pixels[e]),
                  (o = q.isNullOrUndef(s)
                    ? ((u = o.min * r.categoryPercentage), r.barPercentage)
                    : ((u = s * n), 1)),
                  { chunk: u / n, ratio: o, start: a - u / 2 }),
            i = this.getStackIndex(t, this.getMeta().stack),
            e = d.start + d.chunk * i + d.chunk / 2,
            u = Math.min(
              q.valueOrDefault(l.maxBarThickness, 1 / 0),
              d.chunk * d.ratio
            );
          return { base: e - u / 2, head: e + u / 2, center: e, size: u };
        },
        draw: function () {
          var t = this.chart,
            e = this._getValueScale(),
            i = this.getMeta().data,
            n = this.getDataset(),
            a = i.length,
            o = 0;
          for (q.canvas.clipArea(t.ctx, t.chartArea); o < a; ++o)
            isNaN(e.getRightValue(n.data[o])) || i[o].draw();
          q.canvas.unclipArea(t.ctx);
        },
        _resolveElementOptions: function (t, e) {
          for (
            var i,
              n = this.chart,
              a = n.data.datasets[this.index],
              o = t.custom || {},
              r = n.options.elements.rectangle,
              s = {},
              l = {
                chart: n,
                dataIndex: e,
                dataset: a,
                datasetIndex: this.index,
              },
              d = [
                "backgroundColor",
                "borderColor",
                "borderSkipped",
                "borderWidth",
              ],
              u = 0,
              h = d.length;
            u < h;
            ++u
          )
            s[(i = d[u])] = Yt([o[i], a[i], r[i]], l, e);
          return s;
        },
      })),
    Ut = q.valueOrDefault,
    Xt = q.options.resolve,
    o =
      (j._set("bubble", {
        hover: { mode: "single" },
        scales: {
          xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }],
          yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }],
        },
        tooltips: {
          callbacks: {
            title: function () {
              return "";
            },
            label: function (t, e) {
              var i = e.datasets[t.datasetIndex].label || "",
                e = e.datasets[t.datasetIndex].data[t.index];
              return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + e.r + ")";
            },
          },
        },
      }),
      h.extend({
        dataElementType: v.Point,
        update: function (i) {
          var n = this,
            t = n.getMeta().data;
          q.each(t, function (t, e) {
            n.updateElement(t, e, i);
          });
        },
        updateElement: function (t, e, i) {
          var n = this,
            a = n.getMeta(),
            o = t.custom || {},
            r = n.getScaleForId(a.xAxisID),
            a = n.getScaleForId(a.yAxisID),
            s = n._resolveElementOptions(t, e),
            l = n.getDataset().data[e],
            n = n.index,
            d = i
              ? r.getPixelForDecimal(0.5)
              : r.getPixelForValue("object" == typeof l ? l : NaN, e, n),
            l = i ? a.getBasePixel() : a.getPixelForValue(l, e, n);
          (t._xScale = r),
            (t._yScale = a),
            (t._options = s),
            (t._datasetIndex = n),
            (t._index = e),
            (t._model = {
              backgroundColor: s.backgroundColor,
              borderColor: s.borderColor,
              borderWidth: s.borderWidth,
              hitRadius: s.hitRadius,
              pointStyle: s.pointStyle,
              rotation: s.rotation,
              radius: i ? 0 : s.radius,
              skip: o.skip || isNaN(d) || isNaN(l),
              x: d,
              y: l,
            }),
            t.pivot();
        },
        setHoverStyle: function (t) {
          var e = t._model,
            i = t._options,
            n = q.getHoverColor;
          (t.$previousStyle = {
            backgroundColor: e.backgroundColor,
            borderColor: e.borderColor,
            borderWidth: e.borderWidth,
            radius: e.radius,
          }),
            (e.backgroundColor = Ut(
              i.hoverBackgroundColor,
              n(i.backgroundColor)
            )),
            (e.borderColor = Ut(i.hoverBorderColor, n(i.borderColor))),
            (e.borderWidth = Ut(i.hoverBorderWidth, i.borderWidth)),
            (e.radius = i.radius + i.hoverRadius);
        },
        _resolveElementOptions: function (t, e) {
          for (
            var i,
              n = this.chart,
              a = n.data.datasets[this.index],
              o = t.custom || {},
              r = n.options.elements.point,
              t = a.data[e],
              s = {},
              l = {
                chart: n,
                dataIndex: e,
                dataset: a,
                datasetIndex: this.index,
              },
              d = [
                "backgroundColor",
                "borderColor",
                "borderWidth",
                "hoverBackgroundColor",
                "hoverBorderColor",
                "hoverBorderWidth",
                "hoverRadius",
                "hitRadius",
                "pointStyle",
                "rotation",
              ],
              u = 0,
              h = d.length;
            u < h;
            ++u
          )
            s[(i = d[u])] = Xt([o[i], a[i], r[i]], l, e);
          return (
            (s.radius = Xt(
              [o.radius, t ? t.r : void 0, a.radius, r.radius],
              l,
              e
            )),
            s
          );
        },
      })),
    Kt = q.options.resolve,
    Gt = q.valueOrDefault,
    p =
      (j._set("doughnut", {
        animation: { animateRotate: !0, animateScale: !1 },
        hover: { mode: "single" },
        legendCallback: function (t) {
          var e = [],
            t = (e.push('<ul class="' + t.id + '-legend">'), t.data),
            i = t.datasets,
            n = t.labels;
          if (i.length)
            for (var a = 0; a < i[0].data.length; ++a)
              e.push(
                '<li><span style="background-color:' +
                  i[0].backgroundColor[a] +
                  '"></span>'
              ),
                n[a] && e.push(n[a]),
                e.push("</li>");
          return e.push("</ul>"), e.join("");
        },
        legend: {
          labels: {
            generateLabels: function (r) {
              var s = r.data;
              return s.labels.length && s.datasets.length
                ? s.labels.map(function (t, e) {
                    var i = r.getDatasetMeta(0),
                      n = s.datasets[0],
                      a = i.data[e],
                      a = (a && a.custom) || {},
                      o = r.options.elements.arc;
                    return {
                      text: t,
                      fillStyle: Kt(
                        [
                          a.backgroundColor,
                          n.backgroundColor,
                          o.backgroundColor,
                        ],
                        void 0,
                        e
                      ),
                      strokeStyle: Kt(
                        [a.borderColor, n.borderColor, o.borderColor],
                        void 0,
                        e
                      ),
                      lineWidth: Kt(
                        [a.borderWidth, n.borderWidth, o.borderWidth],
                        void 0,
                        e
                      ),
                      hidden: isNaN(n.data[e]) || i.data[e].hidden,
                      index: e,
                    };
                  })
                : [];
            },
          },
          onClick: function (t, e) {
            for (
              var i,
                n = e.index,
                a = this.chart,
                o = 0,
                r = (a.data.datasets || []).length;
              o < r;
              ++o
            )
              (i = a.getDatasetMeta(o)).data[n] &&
                (i.data[n].hidden = !i.data[n].hidden);
            a.update();
          },
        },
        cutoutPercentage: 50,
        rotation: -0.5 * Math.PI,
        circumference: 2 * Math.PI,
        tooltips: {
          callbacks: {
            title: function () {
              return "";
            },
            label: function (t, e) {
              var i = e.labels[t.index],
                e = ": " + e.datasets[t.datasetIndex].data[t.index];
              return q.isArray(i) ? ((i = i.slice())[0] += e) : (i += e), i;
            },
          },
        },
      }),
      h.extend({
        dataElementType: v.Arc,
        linkScales: q.noop,
        getRingIndex: function (t) {
          for (var e = 0, i = 0; i < t; ++i)
            this.chart.isDatasetVisible(i) && ++e;
          return e;
        },
        update: function (t) {
          var e,
            i,
            n,
            a,
            o,
            r,
            s,
            l,
            d,
            u = this,
            h = u.chart,
            c = h.chartArea,
            f = h.options,
            g = c.right - c.left,
            c = c.bottom - c.top,
            p = Math.min(g, c),
            m = { x: 0, y: 0 },
            b = u.getMeta(),
            v = b.data,
            x = f.cutoutPercentage,
            y = f.circumference,
            k = u._getRingWeight(u.index);
          for (
            y < 2 * Math.PI &&
              ((f = f.rotation % (2 * Math.PI)),
              (y =
                (f +=
                  2 * Math.PI * (f >= Math.PI ? -1 : f < -Math.PI ? 1 : 0)) +
                y),
              (d = Math.cos(f)),
              (n = Math.sin(f)),
              (a = Math.cos(y)),
              (o = Math.sin(y)),
              (l =
                (f <= 0 && 0 <= y) || (f <= 2 * Math.PI && 2 * Math.PI <= y)),
              (r =
                (f <= 0.5 * Math.PI && 0.5 * Math.PI <= y) ||
                (f <= 2.5 * Math.PI && 2.5 * Math.PI <= y)),
              (s =
                (f <= -Math.PI && -Math.PI <= y) ||
                (f <= Math.PI && Math.PI <= y)),
              (f =
                (f <= 0.5 * -Math.PI && 0.5 * -Math.PI <= y) ||
                (f <= 1.5 * Math.PI && 1.5 * Math.PI <= y)),
              (y = x / 100),
              (s = s ? -1 : Math.min(d * (d < 0 ? 1 : y), a * (a < 0 ? 1 : y))),
              (f = f ? -1 : Math.min(n * (n < 0 ? 1 : y), o * (o < 0 ? 1 : y))),
              (l = l ? 1 : Math.max(d * (0 < d ? 1 : y), a * (0 < a ? 1 : y))),
              (d = r ? 1 : Math.max(n * (0 < n ? 1 : y), o * (0 < o ? 1 : y))),
              (p = Math.min(g / (0.5 * (l - s)), c / (0.5 * (d - f)))),
              (m = { x: -0.5 * (l + s), y: -0.5 * (d + f) })),
              e = 0,
              i = v.length;
            e < i;
            ++e
          )
            v[e]._options = u._resolveElementOptions(v[e], e);
          for (
            h.borderWidth = u.getMaxBorderWidth(),
              h.outerRadius = Math.max((p - h.borderWidth) / 2, 0),
              h.innerRadius = Math.max(x ? (h.outerRadius / 100) * x : 0, 0),
              h.radiusLength =
                (h.outerRadius - h.innerRadius) /
                (u._getVisibleDatasetWeightTotal() || 1),
              h.offsetX = m.x * h.outerRadius,
              h.offsetY = m.y * h.outerRadius,
              b.total = u.calculateTotal(),
              u.outerRadius =
                h.outerRadius -
                h.radiusLength * u._getRingWeightOffset(u.index),
              u.innerRadius = Math.max(u.outerRadius - h.radiusLength * k, 0),
              e = 0,
              i = v.length;
            e < i;
            ++e
          )
            u.updateElement(v[e], e, t);
        },
        updateElement: function (t, e, i) {
          var n = this,
            a = n.chart,
            o = a.chartArea,
            r = a.options,
            s = r.animation,
            l = (o.left + o.right) / 2,
            o = (o.top + o.bottom) / 2,
            d = r.rotation,
            u = r.rotation,
            h = n.getDataset(),
            c =
              (i && s.animateRotate) || t.hidden
                ? 0
                : n.calculateCircumference(h.data[e]) *
                  (r.circumference / (2 * Math.PI)),
            f = i && s.animateScale ? 0 : n.innerRadius,
            g = i && s.animateScale ? 0 : n.outerRadius,
            p = t._options || {},
            p =
              (q.extend(t, {
                _datasetIndex: n.index,
                _index: e,
                _model: {
                  backgroundColor: p.backgroundColor,
                  borderColor: p.borderColor,
                  borderWidth: p.borderWidth,
                  borderAlign: p.borderAlign,
                  x: l + a.offsetX,
                  y: o + a.offsetY,
                  startAngle: d,
                  endAngle: u,
                  circumference: c,
                  outerRadius: g,
                  innerRadius: f,
                  label: q.valueAtIndexOrDefault(h.label, e, a.data.labels[e]),
                },
              }),
              t._model);
          (i && s.animateRotate) ||
            ((p.startAngle =
              0 === e ? r.rotation : n.getMeta().data[e - 1]._model.endAngle),
            (p.endAngle = p.startAngle + p.circumference)),
            t.pivot();
        },
        calculateTotal: function () {
          var i,
            n = this.getDataset(),
            t = this.getMeta(),
            a = 0;
          return (
            q.each(t.data, function (t, e) {
              (i = n.data[e]), isNaN(i) || t.hidden || (a += Math.abs(i));
            }),
            a
          );
        },
        calculateCircumference: function (t) {
          var e = this.getMeta().total;
          return 0 < e && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0;
        },
        getMaxBorderWidth: function (t) {
          var e,
            i,
            n,
            a,
            o,
            r,
            s = 0,
            l = this.chart;
          if (!t)
            for (e = 0, i = l.data.datasets.length; e < i; ++e)
              if (l.isDatasetVisible(e)) {
                (t = (n = l.getDatasetMeta(e)).data),
                  e !== this.index && (a = n.controller);
                break;
              }
          if (!t) return 0;
          for (e = 0, i = t.length; e < i; ++e)
            (r = t[e]),
              "inner" !==
                (r = a ? a._resolveElementOptions(r, e) : r._options)
                  .borderAlign &&
                ((o = r.borderWidth),
                (s = (r = r.hoverBorderWidth) > (s = s < o ? o : s) ? r : s));
          return s;
        },
        setHoverStyle: function (t) {
          var e = t._model,
            i = t._options,
            n = q.getHoverColor;
          (t.$previousStyle = {
            backgroundColor: e.backgroundColor,
            borderColor: e.borderColor,
            borderWidth: e.borderWidth,
          }),
            (e.backgroundColor = Gt(
              i.hoverBackgroundColor,
              n(i.backgroundColor)
            )),
            (e.borderColor = Gt(i.hoverBorderColor, n(i.borderColor))),
            (e.borderWidth = Gt(i.hoverBorderWidth, i.borderWidth));
        },
        _resolveElementOptions: function (t, e) {
          for (
            var i,
              n = this.chart,
              a = this.getDataset(),
              o = t.custom || {},
              r = n.options.elements.arc,
              s = {},
              l = {
                chart: n,
                dataIndex: e,
                dataset: a,
                datasetIndex: this.index,
              },
              d = [
                "backgroundColor",
                "borderColor",
                "borderWidth",
                "borderAlign",
                "hoverBackgroundColor",
                "hoverBorderColor",
                "hoverBorderWidth",
              ],
              u = 0,
              h = d.length;
            u < h;
            ++u
          )
            s[(i = d[u])] = Kt([o[i], a[i], r[i]], l, e);
          return s;
        },
        _getRingWeightOffset: function (t) {
          for (var e = 0, i = 0; i < t; ++i)
            this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
          return e;
        },
        _getRingWeight: function (t) {
          return Math.max(Gt(this.chart.data.datasets[t].weight, 1), 0);
        },
        _getVisibleDatasetWeightTotal: function () {
          return this._getRingWeightOffset(this.chart.data.datasets.length);
        },
      })),
    m =
      (j._set("horizontalBar", {
        hover: { mode: "index", axis: "y" },
        scales: {
          xAxes: [{ type: "linear", position: "bottom" }],
          yAxes: [
            {
              type: "category",
              position: "left",
              categoryPercentage: 0.8,
              barPercentage: 0.9,
              offset: !0,
              gridLines: { offsetGridLines: !0 },
            },
          ],
        },
        elements: { rectangle: { borderSkipped: "left" } },
        tooltips: { mode: "index", axis: "y" },
      }),
      a.extend({
        _getValueScaleId: function () {
          return this.getMeta().xAxisID;
        },
        _getIndexScaleId: function () {
          return this.getMeta().yAxisID;
        },
      })),
    x = q.valueOrDefault,
    Zt = q.options.resolve,
    $t = q.canvas._isPointInArea;
  function Jt(t, e) {
    return x(t.showLine, e.showLines);
  }
  j._set("line", {
    showLines: !0,
    spanGaps: !1,
    hover: { mode: "label" },
    scales: {
      xAxes: [{ type: "category", id: "x-axis-0" }],
      yAxes: [{ type: "linear", id: "y-axis-0" }],
    },
  });
  var Qt = h.extend({
      datasetElementType: v.Line,
      dataElementType: v.Point,
      update: function (t) {
        var e,
          i,
          n = this,
          a = n.getMeta(),
          o = a.dataset,
          r = a.data || [],
          a = n.getScaleForId(a.yAxisID),
          s = n.getDataset(),
          l = Jt(s, n.chart.options);
        for (
          l &&
            (void 0 !== s.tension &&
              void 0 === s.lineTension &&
              (s.lineTension = s.tension),
            (o._scale = a),
            (o._datasetIndex = n.index),
            (o._children = r),
            (o._model = n._resolveLineOptions(o)),
            o.pivot()),
            e = 0,
            i = r.length;
          e < i;
          ++e
        )
          n.updateElement(r[e], e, t);
        for (
          l && 0 !== o._model.tension && n.updateBezierControlPoints(),
            e = 0,
            i = r.length;
          e < i;
          ++e
        )
          r[e].pivot();
      },
      updateElement: function (t, e, i) {
        var n = this,
          a = n.getMeta(),
          o = t.custom || {},
          r = n.getDataset(),
          s = n.index,
          r = r.data[e],
          l = n.getScaleForId(a.yAxisID),
          d = n.getScaleForId(a.xAxisID),
          a = a.dataset._model,
          u = n._resolvePointOptions(t, e),
          h = d.getPixelForValue("object" == typeof r ? r : NaN, e, s),
          i = i ? l.getBasePixel() : n.calculatePointY(r, e, s);
        (t._xScale = d),
          (t._yScale = l),
          (t._options = u),
          (t._datasetIndex = s),
          (t._index = e),
          (t._model = {
            x: h,
            y: i,
            skip: o.skip || isNaN(h) || isNaN(i),
            radius: u.radius,
            pointStyle: u.pointStyle,
            rotation: u.rotation,
            backgroundColor: u.backgroundColor,
            borderColor: u.borderColor,
            borderWidth: u.borderWidth,
            tension: x(o.tension, a ? a.tension : 0),
            steppedLine: !!a && a.steppedLine,
            hitRadius: u.hitRadius,
          });
      },
      _resolvePointOptions: function (t, e) {
        for (
          var i,
            n = this.chart,
            a = n.data.datasets[this.index],
            o = t.custom || {},
            r = n.options.elements.point,
            s = {},
            l = {
              chart: n,
              dataIndex: e,
              dataset: a,
              datasetIndex: this.index,
            },
            d = {
              backgroundColor: "pointBackgroundColor",
              borderColor: "pointBorderColor",
              borderWidth: "pointBorderWidth",
              hitRadius: "pointHitRadius",
              hoverBackgroundColor: "pointHoverBackgroundColor",
              hoverBorderColor: "pointHoverBorderColor",
              hoverBorderWidth: "pointHoverBorderWidth",
              hoverRadius: "pointHoverRadius",
              pointStyle: "pointStyle",
              radius: "pointRadius",
              rotation: "pointRotation",
            },
            u = Object.keys(d),
            h = 0,
            c = u.length;
          h < c;
          ++h
        )
          s[(i = u[h])] = Zt([o[i], a[d[i]], a[i], r[i]], l, e);
        return s;
      },
      _resolveLineOptions: function (t) {
        for (
          var e,
            i = this.chart,
            n = i.data.datasets[this.index],
            a = t.custom || {},
            t = i.options,
            o = t.elements.line,
            r = {},
            s = [
              "backgroundColor",
              "borderWidth",
              "borderColor",
              "borderCapStyle",
              "borderDash",
              "borderDashOffset",
              "borderJoinStyle",
              "fill",
              "cubicInterpolationMode",
            ],
            l = 0,
            d = s.length;
          l < d;
          ++l
        )
          r[(e = s[l])] = Zt([a[e], n[e], o[e]]);
        return (
          (r.spanGaps = x(n.spanGaps, t.spanGaps)),
          (r.tension = x(n.lineTension, o.tension)),
          (r.steppedLine = Zt([a.steppedLine, n.steppedLine, o.stepped])),
          r
        );
      },
      calculatePointY: function (t, e, i) {
        var n,
          a = this.chart,
          o = this.getMeta(),
          r = this.getScaleForId(o.yAxisID),
          s = 0,
          l = 0;
        if (r.options.stacked) {
          for (n = 0; n < i; n++) {
            var d,
              u = a.data.datasets[n];
            "line" === (d = a.getDatasetMeta(n)).type &&
              d.yAxisID === r.id &&
              a.isDatasetVisible(n) &&
              ((d = Number(r.getRightValue(u.data[e]))) < 0
                ? (l += d || 0)
                : (s += d || 0));
          }
          o = Number(r.getRightValue(t));
          return o < 0 ? r.getPixelForValue(l + o) : r.getPixelForValue(s + o);
        }
        return r.getPixelForValue(t);
      },
      updateBezierControlPoints: function () {
        var t,
          e,
          i,
          n,
          a = this.chart,
          o = this.getMeta(),
          r = o.dataset._model,
          s = a.chartArea,
          l = o.data || [];
        function d(t, e, i) {
          return Math.max(Math.min(t, i), e);
        }
        if (
          (r.spanGaps &&
            (l = l.filter(function (t) {
              return !t._model.skip;
            })),
          "monotone" === r.cubicInterpolationMode)
        )
          q.splineCurveMonotone(l);
        else
          for (t = 0, e = l.length; t < e; ++t)
            (i = l[t]._model),
              (n = q.splineCurve(
                q.previousItem(l, t)._model,
                i,
                q.nextItem(l, t)._model,
                r.tension
              )),
              (i.controlPointPreviousX = n.previous.x),
              (i.controlPointPreviousY = n.previous.y),
              (i.controlPointNextX = n.next.x),
              (i.controlPointNextY = n.next.y);
        if (a.options.elements.line.capBezierPoints)
          for (t = 0, e = l.length; t < e; ++t)
            (i = l[t]._model),
              $t(i, s) &&
                (0 < t &&
                  $t(l[t - 1]._model, s) &&
                  ((i.controlPointPreviousX = d(
                    i.controlPointPreviousX,
                    s.left,
                    s.right
                  )),
                  (i.controlPointPreviousY = d(
                    i.controlPointPreviousY,
                    s.top,
                    s.bottom
                  ))),
                t < l.length - 1) &&
                $t(l[t + 1]._model, s) &&
                ((i.controlPointNextX = d(
                  i.controlPointNextX,
                  s.left,
                  s.right
                )),
                (i.controlPointNextY = d(
                  i.controlPointNextY,
                  s.top,
                  s.bottom
                )));
      },
      draw: function () {
        var t,
          e = this.chart,
          i = this.getMeta(),
          n = i.data || [],
          a = e.chartArea,
          o = n.length,
          r = 0;
        for (
          Jt(this.getDataset(), e.options) &&
          ((t = (i.dataset._model.borderWidth || 0) / 2),
          q.canvas.clipArea(e.ctx, {
            left: a.left,
            right: a.right,
            top: a.top - t,
            bottom: a.bottom + t,
          }),
          i.dataset.draw(),
          q.canvas.unclipArea(e.ctx));
          r < o;
          ++r
        )
          n[r].draw(a);
      },
      setHoverStyle: function (t) {
        var e = t._model,
          i = t._options,
          n = q.getHoverColor;
        (t.$previousStyle = {
          backgroundColor: e.backgroundColor,
          borderColor: e.borderColor,
          borderWidth: e.borderWidth,
          radius: e.radius,
        }),
          (e.backgroundColor = x(i.hoverBackgroundColor, n(i.backgroundColor))),
          (e.borderColor = x(i.hoverBorderColor, n(i.borderColor))),
          (e.borderWidth = x(i.hoverBorderWidth, i.borderWidth)),
          (e.radius = x(i.hoverRadius, i.radius));
      },
    }),
    te = q.options.resolve,
    y =
      (j._set("polarArea", {
        scale: {
          type: "radialLinear",
          angleLines: { display: !1 },
          gridLines: { circular: !0 },
          pointLabels: { display: !1 },
          ticks: { beginAtZero: !0 },
        },
        animation: { animateRotate: !0, animateScale: !0 },
        startAngle: -0.5 * Math.PI,
        legendCallback: function (t) {
          var e = [],
            t = (e.push('<ul class="' + t.id + '-legend">'), t.data),
            i = t.datasets,
            n = t.labels;
          if (i.length)
            for (var a = 0; a < i[0].data.length; ++a)
              e.push(
                '<li><span style="background-color:' +
                  i[0].backgroundColor[a] +
                  '"></span>'
              ),
                n[a] && e.push(n[a]),
                e.push("</li>");
          return e.push("</ul>"), e.join("");
        },
        legend: {
          labels: {
            generateLabels: function (r) {
              var s = r.data;
              return s.labels.length && s.datasets.length
                ? s.labels.map(function (t, e) {
                    var i = r.getDatasetMeta(0),
                      n = s.datasets[0],
                      a = i.data[e].custom || {},
                      o = r.options.elements.arc;
                    return {
                      text: t,
                      fillStyle: te(
                        [
                          a.backgroundColor,
                          n.backgroundColor,
                          o.backgroundColor,
                        ],
                        void 0,
                        e
                      ),
                      strokeStyle: te(
                        [a.borderColor, n.borderColor, o.borderColor],
                        void 0,
                        e
                      ),
                      lineWidth: te(
                        [a.borderWidth, n.borderWidth, o.borderWidth],
                        void 0,
                        e
                      ),
                      hidden: isNaN(n.data[e]) || i.data[e].hidden,
                      index: e,
                    };
                  })
                : [];
            },
          },
          onClick: function (t, e) {
            for (
              var i,
                n = e.index,
                a = this.chart,
                o = 0,
                r = (a.data.datasets || []).length;
              o < r;
              ++o
            )
              (i = a.getDatasetMeta(o)).data[n].hidden = !i.data[n].hidden;
            a.update();
          },
        },
        tooltips: {
          callbacks: {
            title: function () {
              return "";
            },
            label: function (t, e) {
              return e.labels[t.index] + ": " + t.yLabel;
            },
          },
        },
      }),
      h.extend({
        dataElementType: v.Arc,
        linkScales: q.noop,
        update: function (t) {
          var e,
            i,
            n,
            a = this,
            o = a.getDataset(),
            r = a.getMeta(),
            s = a.chart.options.startAngle || 0,
            l = (a._starts = []),
            d = (a._angles = []),
            u = r.data;
          for (
            a._updateRadius(),
              r.count = a.countVisibleElements(),
              e = 0,
              i = o.data.length;
            e < i;
            e++
          )
            (l[e] = s), (n = a._computeAngle(e)), (s += d[e] = n);
          for (e = 0, i = u.length; e < i; ++e)
            (u[e]._options = a._resolveElementOptions(u[e], e)),
              a.updateElement(u[e], e, t);
        },
        _updateRadius: function () {
          var t = this,
            e = t.chart,
            i = e.chartArea,
            n = e.options,
            i = Math.min(i.right - i.left, i.bottom - i.top);
          (e.outerRadius = Math.max(i / 2, 0)),
            (e.innerRadius = Math.max(
              n.cutoutPercentage
                ? (e.outerRadius / 100) * n.cutoutPercentage
                : 1,
              0
            )),
            (e.radiusLength =
              (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount()),
            (t.outerRadius = e.outerRadius - e.radiusLength * t.index),
            (t.innerRadius = t.outerRadius - e.radiusLength);
        },
        updateElement: function (t, e, i) {
          var n = this,
            a = n.chart,
            o = n.getDataset(),
            r = a.options,
            s = r.animation,
            l = a.scale,
            a = a.data.labels,
            d = l.xCenter,
            u = l.yCenter,
            r = r.startAngle,
            h = t.hidden ? 0 : l.getDistanceFromCenterForValue(o.data[e]),
            c = n._starts[e],
            f = c + (t.hidden ? 0 : n._angles[e]),
            o = s.animateScale ? 0 : l.getDistanceFromCenterForValue(o.data[e]),
            g = t._options || {};
          q.extend(t, {
            _datasetIndex: n.index,
            _index: e,
            _scale: l,
            _model: {
              backgroundColor: g.backgroundColor,
              borderColor: g.borderColor,
              borderWidth: g.borderWidth,
              borderAlign: g.borderAlign,
              x: d,
              y: u,
              innerRadius: 0,
              outerRadius: i ? o : h,
              startAngle: i && s.animateRotate ? r : c,
              endAngle: i && s.animateRotate ? r : f,
              label: q.valueAtIndexOrDefault(a, e, a[e]),
            },
          }),
            t.pivot();
        },
        countVisibleElements: function () {
          var i = this.getDataset(),
            t = this.getMeta(),
            n = 0;
          return (
            q.each(t.data, function (t, e) {
              isNaN(i.data[e]) || t.hidden || n++;
            }),
            n
          );
        },
        setHoverStyle: function (t) {
          var e = t._model,
            i = t._options,
            n = q.getHoverColor,
            a = q.valueOrDefault;
          (t.$previousStyle = {
            backgroundColor: e.backgroundColor,
            borderColor: e.borderColor,
            borderWidth: e.borderWidth,
          }),
            (e.backgroundColor = a(
              i.hoverBackgroundColor,
              n(i.backgroundColor)
            )),
            (e.borderColor = a(i.hoverBorderColor, n(i.borderColor))),
            (e.borderWidth = a(i.hoverBorderWidth, i.borderWidth));
        },
        _resolveElementOptions: function (t, e) {
          for (
            var i,
              n = this.chart,
              a = this.getDataset(),
              o = t.custom || {},
              r = n.options.elements.arc,
              s = {},
              l = {
                chart: n,
                dataIndex: e,
                dataset: a,
                datasetIndex: this.index,
              },
              d = [
                "backgroundColor",
                "borderColor",
                "borderWidth",
                "borderAlign",
                "hoverBackgroundColor",
                "hoverBorderColor",
                "hoverBorderWidth",
              ],
              u = 0,
              h = d.length;
            u < h;
            ++u
          )
            s[(i = d[u])] = te([o[i], a[i], r[i]], l, e);
          return s;
        },
        _computeAngle: function (t) {
          var e = this,
            i = this.getMeta().count,
            n = e.getDataset(),
            a = e.getMeta();
          return isNaN(n.data[t]) || a.data[t].hidden
            ? 0
            : ((a = {
                chart: e.chart,
                dataIndex: t,
                dataset: n,
                datasetIndex: e.index,
              }),
              te(
                [e.chart.options.elements.arc.angle, (2 * Math.PI) / i],
                a,
                t
              ));
        },
      })),
    ee =
      (j._set("pie", q.clone(j.doughnut)),
      j._set("pie", { cutoutPercentage: 0 }),
      p),
    ie = q.valueOrDefault,
    ne = q.options.resolve,
    ae =
      (j._set("radar", {
        scale: { type: "radialLinear" },
        elements: { line: { tension: 0 } },
      }),
      h.extend({
        datasetElementType: v.Line,
        dataElementType: v.Point,
        linkScales: q.noop,
        update: function (t) {
          var e,
            i,
            n = this,
            a = n.getMeta(),
            o = a.dataset,
            r = a.data || [],
            a = n.chart.scale,
            s = n.getDataset();
          for (
            void 0 !== s.tension &&
              void 0 === s.lineTension &&
              (s.lineTension = s.tension),
              o._scale = a,
              o._datasetIndex = n.index,
              o._children = r,
              o._loop = !0,
              o._model = n._resolveLineOptions(o),
              o.pivot(),
              e = 0,
              i = r.length;
            e < i;
            ++e
          )
            n.updateElement(r[e], e, t);
          for (n.updateBezierControlPoints(), e = 0, i = r.length; e < i; ++e)
            r[e].pivot();
        },
        updateElement: function (t, e, i) {
          var n = this,
            a = t.custom || {},
            o = n.getDataset(),
            r = n.chart.scale,
            o = r.getPointPositionForValue(e, o.data[e]),
            s = n._resolvePointOptions(t, e),
            l = n.getMeta().dataset._model,
            d = i ? r.xCenter : o.x,
            i = i ? r.yCenter : o.y;
          (t._scale = r),
            (t._options = s),
            (t._datasetIndex = n.index),
            (t._index = e),
            (t._model = {
              x: d,
              y: i,
              skip: a.skip || isNaN(d) || isNaN(i),
              radius: s.radius,
              pointStyle: s.pointStyle,
              rotation: s.rotation,
              backgroundColor: s.backgroundColor,
              borderColor: s.borderColor,
              borderWidth: s.borderWidth,
              tension: ie(a.tension, l ? l.tension : 0),
              hitRadius: s.hitRadius,
            });
        },
        _resolvePointOptions: function (t, e) {
          for (
            var i,
              n = this.chart,
              a = n.data.datasets[this.index],
              o = t.custom || {},
              r = n.options.elements.point,
              s = {},
              l = {
                chart: n,
                dataIndex: e,
                dataset: a,
                datasetIndex: this.index,
              },
              d = {
                backgroundColor: "pointBackgroundColor",
                borderColor: "pointBorderColor",
                borderWidth: "pointBorderWidth",
                hitRadius: "pointHitRadius",
                hoverBackgroundColor: "pointHoverBackgroundColor",
                hoverBorderColor: "pointHoverBorderColor",
                hoverBorderWidth: "pointHoverBorderWidth",
                hoverRadius: "pointHoverRadius",
                pointStyle: "pointStyle",
                radius: "pointRadius",
                rotation: "pointRotation",
              },
              u = Object.keys(d),
              h = 0,
              c = u.length;
            h < c;
            ++h
          )
            s[(i = u[h])] = ne([o[i], a[d[i]], a[i], r[i]], l, e);
          return s;
        },
        _resolveLineOptions: function (t) {
          for (
            var e,
              i = this.chart,
              n = i.data.datasets[this.index],
              a = t.custom || {},
              o = i.options.elements.line,
              r = {},
              s = [
                "backgroundColor",
                "borderWidth",
                "borderColor",
                "borderCapStyle",
                "borderDash",
                "borderDashOffset",
                "borderJoinStyle",
                "fill",
              ],
              l = 0,
              d = s.length;
            l < d;
            ++l
          )
            r[(e = s[l])] = ne([a[e], n[e], o[e]]);
          return (r.tension = ie(n.lineTension, o.tension)), r;
        },
        updateBezierControlPoints: function () {
          var t,
            e,
            i,
            n,
            a = this.getMeta(),
            o = this.chart.chartArea,
            r = a.data || [];
          function s(t, e, i) {
            return Math.max(Math.min(t, i), e);
          }
          for (t = 0, e = r.length; t < e; ++t)
            (i = r[t]._model),
              (n = q.splineCurve(
                q.previousItem(r, t, !0)._model,
                i,
                q.nextItem(r, t, !0)._model,
                i.tension
              )),
              (i.controlPointPreviousX = s(n.previous.x, o.left, o.right)),
              (i.controlPointPreviousY = s(n.previous.y, o.top, o.bottom)),
              (i.controlPointNextX = s(n.next.x, o.left, o.right)),
              (i.controlPointNextY = s(n.next.y, o.top, o.bottom));
        },
        setHoverStyle: function (t) {
          var e = t._model,
            i = t._options,
            n = q.getHoverColor;
          (t.$previousStyle = {
            backgroundColor: e.backgroundColor,
            borderColor: e.borderColor,
            borderWidth: e.borderWidth,
            radius: e.radius,
          }),
            (e.backgroundColor = ie(
              i.hoverBackgroundColor,
              n(i.backgroundColor)
            )),
            (e.borderColor = ie(i.hoverBorderColor, n(i.borderColor))),
            (e.borderWidth = ie(i.hoverBorderWidth, i.borderWidth)),
            (e.radius = ie(i.hoverRadius, i.radius));
        },
      })),
    oe =
      (j._set("scatter", {
        hover: { mode: "single" },
        scales: {
          xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }],
          yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }],
        },
        showLines: !1,
        tooltips: {
          callbacks: {
            title: function () {
              return "";
            },
            label: function (t) {
              return "(" + t.xLabel + ", " + t.yLabel + ")";
            },
          },
        },
      }),
      {
        bar: a,
        bubble: o,
        doughnut: p,
        horizontalBar: m,
        line: Qt,
        polarArea: y,
        pie: ee,
        radar: ae,
        scatter: Qt,
      });
  function k(t, e) {
    return t.native ? { x: t.x, y: t.y } : q.getRelativePosition(t, e);
  }
  function re(t, e) {
    for (var i, n, a, o = 0, r = t.data.datasets.length; o < r; ++o)
      if (t.isDatasetVisible(o))
        for (n = 0, a = (i = t.getDatasetMeta(o)).data.length; n < a; ++n) {
          var s = i.data[n];
          s._view.skip || e(s);
        }
  }
  function se(t, e) {
    var i = [];
    return (
      re(t, function (t) {
        t.inRange(e.x, e.y) && i.push(t);
      }),
      i
    );
  }
  function le(t, i, n, a) {
    var o = Number.POSITIVE_INFINITY,
      r = [];
    return (
      re(t, function (t) {
        var e;
        (n && !t.inRange(i.x, i.y)) ||
          ((e = t.getCenterPoint()),
          (e = a(i, e)) < o ? ((r = [t]), (o = e)) : e === o && r.push(t));
      }),
      r
    );
  }
  function de(t) {
    var n = -1 !== t.indexOf("x"),
      a = -1 !== t.indexOf("y");
    return function (t, e) {
      var i = n ? Math.abs(t.x - e.x) : 0,
        t = a ? Math.abs(t.y - e.y) : 0;
      return Math.sqrt(Math.pow(i, 2) + Math.pow(t, 2));
    };
  }
  function ue(i, t, e) {
    var t = k(t, i),
      n = ((e.axis = e.axis || "x"), de(e.axis)),
      a = e.intersect ? se(i, t) : le(i, t, !1, n),
      o = [];
    return a.length
      ? (i.data.datasets.forEach(function (t, e) {
          i.isDatasetVisible(e) &&
            (e = i.getDatasetMeta(e).data[a[0]._index]) &&
            !e._view.skip &&
            o.push(e);
        }),
        o)
      : [];
  }
  var he = {
    modes: {
      single: function (t, e) {
        var i = k(e, t),
          n = [];
        return (
          re(t, function (t) {
            t.inRange(i.x, i.y) && n.push(t);
          }),
          n.slice(0, 1)
        );
      },
      label: ue,
      index: ue,
      dataset: function (t, e, i) {
        var e = k(e, t),
          n = ((i.axis = i.axis || "xy"), de(i.axis)),
          i = i.intersect ? se(t, e) : le(t, e, !1, n);
        return (i =
          0 < i.length ? t.getDatasetMeta(i[0]._datasetIndex).data : i);
      },
      "x-axis": function (t, e) {
        return ue(t, e, { intersect: !1 });
      },
      point: function (t, e) {
        return se(t, k(e, t));
      },
      nearest: function (t, e, i) {
        var e = k(e, t),
          n = ((i.axis = i.axis || "xy"), de(i.axis));
        return le(t, e, i.intersect, n);
      },
      x: function (t, e, i) {
        var n = k(e, t),
          a = [],
          o = !1;
        return (
          re(t, function (t) {
            t.inXRange(n.x) && a.push(t), t.inRange(n.x, n.y) && (o = !0);
          }),
          (a = i.intersect && !o ? [] : a)
        );
      },
      y: function (t, e, i) {
        var n = k(e, t),
          a = [],
          o = !1;
        return (
          re(t, function (t) {
            t.inYRange(n.y) && a.push(t), t.inRange(n.x, n.y) && (o = !0);
          }),
          (a = i.intersect && !o ? [] : a)
        );
      },
    },
  };
  function ce(t, e) {
    return q.where(t, function (t) {
      return t.position === e;
    });
  }
  function fe(t, n) {
    t.forEach(function (t, e) {
      return (t._tmpIndex_ = e), t;
    }),
      t.sort(function (t, e) {
        var i = n ? e : t,
          t = n ? t : e;
        return i.weight === t.weight
          ? i._tmpIndex_ - t._tmpIndex_
          : i.weight - t.weight;
      }),
      t.forEach(function (t) {
        delete t._tmpIndex_;
      });
  }
  function ge(t, e) {
    q.each(t, function (t) {
      e[t.position] += t.isHorizontal() ? t.height : t.width;
    });
  }
  j._set("global", {
    layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } },
  });
  var M = {
      defaults: {},
      addBox: function (t, e) {
        t.boxes || (t.boxes = []),
          (e.fullWidth = e.fullWidth || !1),
          (e.position = e.position || "top"),
          (e.weight = e.weight || 0),
          t.boxes.push(e);
      },
      removeBox: function (t, e) {
        e = t.boxes ? t.boxes.indexOf(e) : -1;
        -1 !== e && t.boxes.splice(e, 1);
      },
      configure: function (t, e, i) {
        for (
          var n, a = ["fullWidth", "position", "weight"], o = a.length, r = 0;
          r < o;
          ++r
        )
          i.hasOwnProperty((n = a[r])) && (e[n] = i[n]);
      },
      update: function (e, i, t) {
        var n,
          a,
          o,
          r,
          s,
          l,
          d,
          u,
          h,
          c,
          f,
          g,
          p,
          m,
          b,
          v,
          x,
          y,
          k,
          M,
          w,
          _,
          C,
          S,
          P,
          I,
          A,
          D;
        function T(e) {
          var t,
            i = q.findNextWhere(y, function (t) {
              return t.box === e;
            });
          i &&
            (i.horizontal
              ? ((t = {
                  left: Math.max(x.left, h.left),
                  right: Math.max(x.right, h.right),
                  top: 0,
                  bottom: 0,
                }),
                e.update(e.fullWidth ? g : b, p / 2, t))
              : e.update(i.width, v));
        }
        function F(t) {
          t.isHorizontal()
            ? ((t.left = t.fullWidth ? n : x.left),
              (t.right = t.fullWidth ? i - a : x.left + b),
              (t.top = S),
              (t.bottom = S + t.height),
              (S = t.bottom))
            : ((t.left = C),
              (t.right = C + t.width),
              (t.top = x.top),
              (t.bottom = x.top + v),
              (C = t.right));
        }
        e &&
          ((M = e.options.layout || {}),
          (M = q.options.toPadding(M.padding)),
          (n = M.left),
          (a = M.right),
          (o = M.top),
          (M = M.bottom),
          (r = ce(e.boxes, "left")),
          (s = ce(e.boxes, "right")),
          (l = ce(e.boxes, "top")),
          (d = ce(e.boxes, "bottom")),
          (u = ce(e.boxes, "chartArea")),
          fe(r, !0),
          fe(s, !1),
          fe(l, !0),
          fe(d, !1),
          (c = r.concat(s)),
          (f = l.concat(d)),
          (k = c.concat(f)),
          (m = (i - (g = i - n - a) / 2) / c.length),
          (b = g),
          (v = p = t - o - M),
          (x = { top: o, left: n, bottom: M, right: a }),
          (y = []),
          q.each(k, function (t) {
            var e,
              i = t.isHorizontal();
            i
              ? ((e = t.update(t.fullWidth ? g : b, p / 2)), (v -= e.height))
              : ((e = t.update(m, v)), (b -= e.width)),
              y.push({ horizontal: i, width: e.width, box: t });
          }),
          (D = A = I = P = 0),
          q.each(k, function (t) {
            t.getPadding &&
              ((t = t.getPadding()),
              (P = Math.max(P, t.top)),
              (I = Math.max(I, t.left)),
              (A = Math.max(A, t.bottom)),
              (D = Math.max(D, t.right)));
          }),
          (h = { top: P, left: I, bottom: A, right: D }),
          q.each(c, T),
          ge(c, x),
          q.each(f, T),
          ge(f, x),
          q.each(c, function (e) {
            var t = q.findNextWhere(y, function (t) {
                return t.box === e;
              }),
              i = { left: 0, right: 0, top: x.top, bottom: x.bottom };
            t && e.update(t.width, v, i);
          }),
          ge(k, (x = { top: o, left: n, bottom: M, right: a })),
          (k = Math.max(h.left - x.left, 0)),
          (x.left += k),
          (x.right += Math.max(h.right - x.right, 0)),
          (M = Math.max(h.top - x.top, 0)),
          (x.top += M),
          (x.bottom += Math.max(h.bottom - x.bottom, 0)),
          (w = t - x.top - x.bottom),
          ((_ = i - x.left - x.right) === b && w === v) ||
            (q.each(c, function (t) {
              t.height = w;
            }),
            q.each(f, function (t) {
              t.fullWidth || (t.width = _);
            }),
            (v = w),
            (b = _)),
          (C = n + k),
          (S = o + M),
          q.each(r.concat(l), F),
          (C += b),
          (S += v),
          q.each(s, F),
          q.each(d, F),
          (e.chartArea = {
            left: x.left,
            top: x.top,
            right: x.left + b,
            bottom: x.top + v,
          }),
          q.each(u, function (t) {
            (t.left = e.chartArea.left),
              (t.top = e.chartArea.top),
              (t.right = e.chartArea.right),
              (t.bottom = e.chartArea.bottom),
              t.update(b, v);
          }));
      },
    },
    pe =
      ((a = Object.freeze({
        default:
          "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}",
      })) &&
        a.default) ||
      a,
    w = "$chartjs",
    me = "chartjs-size-monitor",
    be = "chartjs-render-monitor",
    ve = ["animationstart", "webkitAnimationStart"],
    xe = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout",
    };
  function ye(t, e) {
    (t = q.getStyle(t, e)), (e = t && t.match(/^(\d+)(\.\d+)?px$/));
    return e ? Number(e[1]) : void 0;
  }
  var ke = !!(function () {
    var t = !1;
    try {
      var e = Object.defineProperty({}, "passive", {
        get: function () {
          t = !0;
        },
      });
      window.addEventListener("e", null, e);
    } catch (t) {}
    return t;
  })() && { passive: !0 };
  function Me(t, e, i) {
    t.addEventListener(e, i, ke);
  }
  function we(t, e, i) {
    t.removeEventListener(e, i, ke);
  }
  function _e(t, e, i, n, a) {
    return {
      type: t,
      chart: e,
      native: a || null,
      x: void 0 !== i ? i : null,
      y: void 0 !== n ? n : null,
    };
  }
  function Ce(t) {
    var e = document.createElement("div");
    return (e.className = t || ""), e;
  }
  function Se(i, n, a) {
    var t,
      e,
      o,
      r,
      s,
      l,
      d,
      u = i[w] || (i[w] = {}),
      h = (u.resizer = (function (t) {
        function e() {
          i._reset(), t();
        }
        var i = Ce(me),
          n = Ce(me + "-expand"),
          a = Ce(me + "-shrink");
        n.appendChild(Ce()),
          a.appendChild(Ce()),
          i.appendChild(n),
          i.appendChild(a),
          (i._reset = function () {
            (n.scrollLeft = 1e6),
              (n.scrollTop = 1e6),
              (a.scrollLeft = 1e6),
              (a.scrollTop = 1e6);
          });
        return (
          Me(n, "scroll", e.bind(n, "expand")),
          Me(a, "scroll", e.bind(a, "shrink")),
          i
        );
      })(
        ((t = function () {
          var t, e;
          u.resizer &&
            ((e = (t = a.options.maintainAspectRatio && i.parentNode)
              ? t.clientWidth
              : 0),
            n(_e("resize", a)),
            t) &&
            t.clientWidth < e &&
            a.canvas &&
            n(_e("resize", a));
        }),
        (o = !1),
        function () {
          (r = Array.prototype.slice.call(arguments)),
            (e = e || this),
            o ||
              ((o = !0),
              q.requestAnimFrame.call(window, function () {
                (o = !1), t.apply(e, r);
              }));
        })
      ));
    (l = (s = i)[w] || (s[w] = {})),
      (d = l.renderProxy =
        function (t) {
          "chartjs-render-animation" === t.animationName &&
            u.resizer &&
            ((t = i.parentNode) &&
              t !== h.parentNode &&
              t.insertBefore(h, t.firstChild),
            h._reset());
        }),
      q.each(ve, function (t) {
        Me(s, t, d);
      }),
      (l.reflow = !!s.offsetParent),
      s.classList.add(be);
  }
  var o = {
      disableCSSInjection: !1,
      _enabled: "undefined" != typeof window && "undefined" != typeof document,
      _ensureLoaded: function () {
        var t, e;
        this._loaded ||
          ((this._loaded = !0), this.disableCSSInjection) ||
          ((t = pe),
          (e = this._style || document.createElement("style")),
          this._style ||
            ((t = "/* Chart.js */\n" + t),
            (this._style = e).setAttribute("type", "text/css"),
            document.getElementsByTagName("head")[0].appendChild(e)),
          e.appendChild(document.createTextNode(t)));
      },
      acquireContext: function (t, e) {
        "string" == typeof t
          ? (t = document.getElementById(t))
          : t.length && (t = t[0]);
        var i,
          n,
          a,
          o,
          r =
            (t = t && t.canvas ? t.canvas : t) &&
            t.getContext &&
            t.getContext("2d");
        return (
          this._ensureLoaded(),
          r && r.canvas === t
            ? ((e = e),
              (n = (t = t).style),
              (a = t.getAttribute("height")),
              (o = t.getAttribute("width")),
              (t[w] = {
                initial: {
                  height: a,
                  width: o,
                  style: {
                    display: n.display,
                    height: n.height,
                    width: n.width,
                  },
                },
              }),
              (n.display = n.display || "block"),
              (null !== o && "" !== o) ||
                (void 0 !== (i = ye(t, "width")) && (t.width = i)),
              (null !== a && "" !== a) ||
                ("" === t.style.height
                  ? (t.height = t.width / (e.options.aspectRatio || 2))
                  : ((n = ye(t, "height")), void 0 !== i && (t.height = n))),
              r)
            : null
        );
      },
      releaseContext: function (t) {
        var i,
          n = t.canvas;
        n[w] &&
          ((i = n[w].initial),
          ["height", "width"].forEach(function (t) {
            var e = i[t];
            q.isNullOrUndef(e) ? n.removeAttribute(t) : n.setAttribute(t, e);
          }),
          q.each(i.style || {}, function (t, e) {
            n.style[e] = t;
          }),
          (n.width = n.width),
          delete n[w]);
      },
      addEventListener: function (a, t, o) {
        var e,
          i = a.canvas;
        "resize" !== t
          ? Me(
              i,
              t,
              (((e = o[w] || (o[w] = {})).proxies || (e.proxies = {}))[
                a.id + "_" + t
              ] = function (t) {
                var e, i, n;
                o(
                  ((e = a),
                  (i = xe[(t = t).type] || t.type),
                  (n = q.getRelativePosition(t, e)),
                  _e(i, e, n.x, n.y, t))
                );
              })
            )
          : Se(i, o, a);
      },
      removeEventListener: function (t, e, i) {
        var n,
          a,
          o = t.canvas;
        "resize" !== e
          ? (i = ((i[w] || {}).proxies || {})[t.id + "_" + e]) && we(o, e, i)
          : ((e = (t = o)[w] || {}),
            (i = e.resizer),
            delete e.resizer,
            (e = (n = t)[w] || {}),
            (a = e.renderProxy) &&
              (q.each(ve, function (t) {
                we(n, t, a);
              }),
              delete e.renderProxy),
            n.classList.remove(be),
            i && i.parentNode && i.parentNode.removeChild(i));
      },
    },
    p =
      ((q.addEvent = Me),
      (q.removeEvent = we),
      o._enabled
        ? o
        : {
            acquireContext: function (t) {
              return (
                ((t = t && t.canvas ? t.canvas : t) && t.getContext("2d")) ||
                null
              );
            },
          }),
    Pe = q.extend(
      {
        initialize: function () {},
        acquireContext: function () {},
        releaseContext: function () {},
        addEventListener: function () {},
        removeEventListener: function () {},
      },
      p
    ),
    _ =
      (j._set("global", { plugins: {} }),
      {
        _plugins: [],
        _cacheId: 0,
        register: function (t) {
          var e = this._plugins;
          [].concat(t).forEach(function (t) {
            -1 === e.indexOf(t) && e.push(t);
          }),
            this._cacheId++;
        },
        unregister: function (t) {
          var e = this._plugins;
          [].concat(t).forEach(function (t) {
            t = e.indexOf(t);
            -1 !== t && e.splice(t, 1);
          }),
            this._cacheId++;
        },
        clear: function () {
          (this._plugins = []), this._cacheId++;
        },
        count: function () {
          return this._plugins.length;
        },
        getAll: function () {
          return this._plugins;
        },
        notify: function (t, e, i) {
          for (
            var n, a, o, r, s = this.descriptors(t), l = s.length, d = 0;
            d < l;
            ++d
          )
            if (
              "function" == typeof (r = (a = (n = s[d]).plugin)[e]) &&
              ((o = [t].concat(i || [])).push(n.options), !1 === r.apply(a, o))
            )
              return !1;
          return !0;
        },
        descriptors: function (t) {
          var n,
            a,
            o,
            e = t.$plugins || (t.$plugins = {});
          return e.id === this._cacheId
            ? e.descriptors
            : ((n = []),
              (a = []),
              (t = (t && t.config) || {}),
              (o = (t.options && t.options.plugins) || {}),
              this._plugins.concat(t.plugins || []).forEach(function (t) {
                var e, i;
                -1 === n.indexOf(t) &&
                  ((e = t.id), !1 !== (i = o[e])) &&
                  (!0 === i && (i = q.clone(j.global.plugins[e])),
                  n.push(t),
                  a.push({ plugin: t, options: i || {} }));
              }),
              (e.descriptors = a),
              (e.id = this._cacheId),
              a);
        },
        _invalidate: function (t) {
          delete t.$plugins;
        },
      }),
    Ie = {
      constructors: {},
      defaults: {},
      registerScaleType: function (t, e, i) {
        (this.constructors[t] = e), (this.defaults[t] = q.clone(i));
      },
      getScaleConstructor: function (t) {
        return this.constructors.hasOwnProperty(t)
          ? this.constructors[t]
          : void 0;
      },
      getScaleDefaults: function (t) {
        return this.defaults.hasOwnProperty(t)
          ? q.merge({}, [j.scale, this.defaults[t]])
          : {};
      },
      updateScaleDefaults: function (t, e) {
        this.defaults.hasOwnProperty(t) &&
          (this.defaults[t] = q.extend(this.defaults[t], e));
      },
      addScalesToLayout: function (e) {
        q.each(e.scales, function (t) {
          (t.fullWidth = t.options.fullWidth),
            (t.position = t.options.position),
            (t.weight = t.options.weight),
            M.addBox(e, t);
        });
      },
    },
    C = q.valueOrDefault,
    Ae =
      (j._set("global", {
        tooltips: {
          enabled: !0,
          custom: null,
          mode: "nearest",
          position: "average",
          intersect: !0,
          backgroundColor: "rgba(0,0,0,0.8)",
          titleFontStyle: "bold",
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleFontColor: "#fff",
          titleAlign: "left",
          bodySpacing: 2,
          bodyFontColor: "#fff",
          bodyAlign: "left",
          footerFontStyle: "bold",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFontColor: "#fff",
          footerAlign: "left",
          yPadding: 6,
          xPadding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          multiKeyBackground: "#fff",
          displayColors: !0,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          callbacks: {
            beforeTitle: q.noop,
            title: function (t, e) {
              var i = "",
                e = e.labels,
                n = e ? e.length : 0;
              return (
                0 < t.length &&
                  ((t = t[0]).label
                    ? (i = t.label)
                    : t.xLabel
                    ? (i = t.xLabel)
                    : 0 < n && t.index < n && (i = e[t.index])),
                i
              );
            },
            afterTitle: q.noop,
            beforeBody: q.noop,
            beforeLabel: q.noop,
            label: function (t, e) {
              e = e.datasets[t.datasetIndex].label || "";
              return (
                e && (e += ": "),
                q.isNullOrUndef(t.value) ? (e += t.yLabel) : (e += t.value),
                e
              );
            },
            labelColor: function (t, e) {
              e = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;
              return {
                borderColor: e.borderColor,
                backgroundColor: e.backgroundColor,
              };
            },
            labelTextColor: function () {
              return this._options.bodyFontColor;
            },
            afterLabel: q.noop,
            afterBody: q.noop,
            beforeFooter: q.noop,
            footer: q.noop,
            afterFooter: q.noop,
          },
        },
      }),
      {
        average: function (t) {
          if (!t.length) return !1;
          for (var e = 0, i = 0, n = 0, a = 0, o = t.length; a < o; ++a) {
            var r = t[a];
            r &&
              r.hasValue() &&
              ((e += (r = r.tooltipPosition()).x), (i += r.y), ++n);
          }
          return { x: e / n, y: i / n };
        },
        nearest: function (t, e) {
          for (
            var i,
              n,
              a = e.x,
              o = e.y,
              r = Number.POSITIVE_INFINITY,
              s = 0,
              l = t.length;
            s < l;
            ++s
          ) {
            var d,
              u = t[s];
            u &&
              u.hasValue() &&
              ((d = u.getCenterPoint()),
              (d = q.distanceBetweenPoints(e, d)) < r) &&
              ((r = d), (i = u));
          }
          return (
            i && ((a = (n = i.tooltipPosition()).x), (o = n.y)), { x: a, y: o }
          );
        },
      });
  function S(t, e) {
    return (
      e && (q.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
    );
  }
  function P(t) {
    return ("string" == typeof t || t instanceof String) && -1 < t.indexOf("\n")
      ? t.split("\n")
      : t;
  }
  function De(t) {
    var e = j.global;
    return {
      xPadding: t.xPadding,
      yPadding: t.yPadding,
      xAlign: t.xAlign,
      yAlign: t.yAlign,
      bodyFontColor: t.bodyFontColor,
      _bodyFontFamily: C(t.bodyFontFamily, e.defaultFontFamily),
      _bodyFontStyle: C(t.bodyFontStyle, e.defaultFontStyle),
      _bodyAlign: t.bodyAlign,
      bodyFontSize: C(t.bodyFontSize, e.defaultFontSize),
      bodySpacing: t.bodySpacing,
      titleFontColor: t.titleFontColor,
      _titleFontFamily: C(t.titleFontFamily, e.defaultFontFamily),
      _titleFontStyle: C(t.titleFontStyle, e.defaultFontStyle),
      titleFontSize: C(t.titleFontSize, e.defaultFontSize),
      _titleAlign: t.titleAlign,
      titleSpacing: t.titleSpacing,
      titleMarginBottom: t.titleMarginBottom,
      footerFontColor: t.footerFontColor,
      _footerFontFamily: C(t.footerFontFamily, e.defaultFontFamily),
      _footerFontStyle: C(t.footerFontStyle, e.defaultFontStyle),
      footerFontSize: C(t.footerFontSize, e.defaultFontSize),
      _footerAlign: t.footerAlign,
      footerSpacing: t.footerSpacing,
      footerMarginTop: t.footerMarginTop,
      caretSize: t.caretSize,
      cornerRadius: t.cornerRadius,
      backgroundColor: t.backgroundColor,
      opacity: 0,
      legendColorBackground: t.multiKeyBackground,
      displayColors: t.displayColors,
      borderColor: t.borderColor,
      borderWidth: t.borderWidth,
    };
  }
  function Te(t, e) {
    return "center" === e
      ? t.x + t.width / 2
      : "right" === e
      ? t.x + t.width - t.xPadding
      : t.x + t.xPadding;
  }
  function Fe(t) {
    return S([], P(t));
  }
  var Le = t.extend({
      initialize: function () {
        (this._model = De(this._options)), (this._lastActive = []);
      },
      getTitle: function () {
        var t = this._options.callbacks,
          e = t.beforeTitle.apply(this, arguments),
          i = t.title.apply(this, arguments),
          t = t.afterTitle.apply(this, arguments),
          n = S((n = []), P(e));
        return (n = S(n, P(i))), S(n, P(t));
      },
      getBeforeBody: function () {
        return Fe(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      getBody: function (t, i) {
        var n = this,
          a = n._options.callbacks,
          o = [];
        return (
          q.each(t, function (t) {
            var e = { before: [], lines: [], after: [] };
            S(e.before, P(a.beforeLabel.call(n, t, i))),
              S(e.lines, a.label.call(n, t, i)),
              S(e.after, P(a.afterLabel.call(n, t, i))),
              o.push(e);
          }),
          o
        );
      },
      getAfterBody: function () {
        return Fe(this._options.callbacks.afterBody.apply(this, arguments));
      },
      getFooter: function () {
        var t = this._options.callbacks,
          e = t.beforeFooter.apply(this, arguments),
          i = t.footer.apply(this, arguments),
          t = t.afterFooter.apply(this, arguments),
          n = S((n = []), P(e));
        return (n = S(n, P(i))), S(n, P(t));
      },
      update: function (z) {
        var t,
          e,
          i,
          n,
          a,
          o,
          r,
          s,
          l,
          d,
          u,
          h,
          B,
          c,
          f,
          g,
          p,
          m,
          b,
          v,
          x,
          y,
          k,
          M,
          w,
          _,
          C = this,
          S = C._options,
          P = C._model,
          I = (C._model = De(S)),
          A = C._active,
          D = C._data,
          T = { xAlign: P.xAlign, yAlign: P.yAlign },
          F = { x: P.x, y: P.y },
          L = { width: P.width, height: P.height },
          P = { x: P.caretX, y: P.caretY };
        if (A.length) {
          I.opacity = 1;
          for (
            var N = [],
              W = [],
              P = Ae[S.position].call(C, A, C._eventPosition),
              R = [],
              V = 0,
              E = A.length;
            V < E;
            ++V
          )
            R.push(
              ((s = r = o = i = e = void 0),
              (e = (t = A[V])._xScale),
              (i = t._yScale || t._scale),
              (n = t._index),
              (a = t._datasetIndex),
              (r = (o =
                t._chart.getDatasetMeta(a).controller)._getIndexScale()),
              (s = o._getValueScale()),
              {
                xLabel: e ? e.getLabelForIndex(n, a) : "",
                yLabel: i ? i.getLabelForIndex(n, a) : "",
                label: r ? "" + r.getLabelForIndex(n, a) : "",
                value: s ? "" + s.getLabelForIndex(n, a) : "",
                index: n,
                datasetIndex: a,
                x: t._model.x,
                y: t._model.y,
              })
            );
          S.filter &&
            (R = R.filter(function (t) {
              return S.filter(t, D);
            })),
            S.itemSort &&
              (R = R.sort(function (t, e) {
                return S.itemSort(t, e, D);
              })),
            q.each(R, function (t) {
              N.push(S.callbacks.labelColor.call(C, t, C._chart)),
                W.push(S.callbacks.labelTextColor.call(C, t, C._chart));
            }),
            (I.title = C.getTitle(R, D)),
            (I.beforeBody = C.getBeforeBody(R, D)),
            (I.body = C.getBody(R, D)),
            (I.afterBody = C.getAfterBody(R, D)),
            (I.footer = C.getFooter(R, D)),
            (I.x = P.x),
            (I.y = P.y),
            (I.caretPadding = S.caretPadding),
            (I.labelColors = N),
            (I.labelTextColors = W),
            (I.dataPoints = R),
            (g = I),
            (p = (f = this)._chart.ctx),
            (f = 2 * g.yPadding),
            (m = 0),
            (b = g.body),
            (v = b.reduce(function (t, e) {
              return t + e.before.length + e.lines.length + e.after.length;
            }, 0)),
            (v += g.beforeBody.length + g.afterBody.length),
            (x = g.title.length),
            (y = g.footer.length),
            (k = g.titleFontSize),
            (M = g.bodyFontSize),
            (w = g.footerFontSize),
            (f =
              (f =
                (f =
                  (f =
                    (f = f + x * k + (x ? (x - 1) * g.titleSpacing : 0)) +
                    (x ? g.titleMarginBottom : 0)) +
                  v * M +
                  (v ? (v - 1) * g.bodySpacing : 0)) +
                (y ? g.footerMarginTop : 0)) +
              y * w +
              (y ? (y - 1) * g.footerSpacing : 0)),
            (_ = 0),
            (p.font = q.fontString(k, g._titleFontStyle, g._titleFontFamily)),
            q.each(g.title, O),
            (p.font = q.fontString(M, g._bodyFontStyle, g._bodyFontFamily)),
            q.each(g.beforeBody.concat(g.afterBody), O),
            (_ = g.displayColors ? M + 2 : 0),
            q.each(b, function (t) {
              q.each(t.before, O), q.each(t.lines, O), q.each(t.after, O);
            }),
            (_ = 0),
            (p.font = q.fontString(w, g._footerFontStyle, g._footerFontFamily)),
            q.each(g.footer, O),
            (L = { width: (m += 2 * g.xPadding), height: f }),
            (x = I),
            (l = v = L),
            (d = (y = this)._model),
            (u = y._chart),
            (k = y._chart.chartArea),
            (b = M = "center"),
            d.y < l.height
              ? (b = "top")
              : d.y > u.height - l.height && (b = "bottom"),
            (h = (k.left + k.right) / 2),
            (B = (k.top + k.bottom) / 2),
            (k =
              "center" === b
                ? ((c = function (t) {
                    return t <= h;
                  }),
                  function (t) {
                    return h < t;
                  })
                : ((c = function (t) {
                    return t <= l.width / 2;
                  }),
                  function (t) {
                    return t >= u.width - l.width / 2;
                  })),
            (w = function (t) {
              return t + l.width + d.caretSize + d.caretPadding > u.width;
            }),
            (g = function (t) {
              return t - l.width - d.caretSize - d.caretPadding < 0;
            }),
            (f = function (t) {
              return t <= B ? "top" : "bottom";
            }),
            c(d.x)
              ? ((M = "left"), w(d.x) && ((M = "center"), (b = f(d.y))))
              : k(d.x) &&
                ((M = "right"), g(d.x)) &&
                ((M = "center"), (b = f(d.y))),
            (c = y._options),
            (w = T = { xAlign: c.xAlign || M, yAlign: c.yAlign || b }),
            (k = C._chart),
            (g = x.x),
            (f = x.y),
            (y = x.caretSize),
            (M = x.caretPadding),
            (x = x.cornerRadius),
            (c = w.xAlign),
            (w = w.yAlign),
            (y += M),
            (x += M),
            "right" === c
              ? (g -= v.width)
              : "center" === c &&
                (g =
                  (g -= v.width / 2) + v.width > k.width
                    ? k.width - v.width
                    : g) < 0 &&
                (g = 0),
            "top" === w
              ? (f += y)
              : (f -= "bottom" === w ? v.height + y : v.height / 2),
            "center" === w
              ? "left" === c
                ? (g += y)
                : "right" === c && (g -= y)
              : "left" === c
              ? (g -= x)
              : "right" === c && (g += x),
            (F = { x: g, y: f });
        } else I.opacity = 0;
        function O(t) {
          m = Math.max(m, p.measureText(t).width + _);
        }
        return (
          (I.xAlign = T.xAlign),
          (I.yAlign = T.yAlign),
          (I.x = F.x),
          (I.y = F.y),
          (I.width = L.width),
          (I.height = L.height),
          (I.caretX = P.x),
          (I.caretY = P.y),
          (C._model = I),
          z && S.custom && S.custom.call(C, I),
          C
        );
      },
      drawCaret: function (t, e) {
        var i = this._chart.ctx,
          n = this._view,
          t = this.getCaretPosition(t, e, n);
        i.lineTo(t.x1, t.y1), i.lineTo(t.x2, t.y2), i.lineTo(t.x3, t.y3);
      },
      getCaretPosition: function (t, e, i) {
        var n,
          a,
          o,
          r,
          s,
          l,
          d = i.caretSize,
          u = i.cornerRadius,
          h = i.xAlign,
          c = i.yAlign,
          f = t.x,
          t = t.y,
          g = e.width,
          e = e.height;
        return (
          "center" === c
            ? ((o = t + e / 2),
              (r =
                "left" === h
                  ? ((n = (l = f) - d), (s = l), (a = o + d), o - d)
                  : ((n = (l = f + g) + d), (s = l), (a = o - d), o + d)))
            : ((s =
                ((l =
                  "left" === h
                    ? (n = f + u + d) - d
                    : "right" === h
                    ? (n = f + g - u - d) - d
                    : (n = i.caretX) - d),
                n + d)),
              "top" === c
                ? ((o = (a = t) - d), (r = a))
                : ((o = (a = t + e) + d), (r = a), (h = s), (s = l), (l = h))),
          { x1: l, x2: n, x3: s, y1: a, y2: o, y3: r }
        );
      },
      drawTitle: function (t, e, i) {
        var n = e.title;
        if (n.length) {
          (t.x = Te(e, e._titleAlign)),
            (i.textAlign = e._titleAlign),
            (i.textBaseline = "top");
          var a,
            o,
            r = e.titleFontSize,
            s = e.titleSpacing;
          for (
            i.fillStyle = e.titleFontColor,
              i.font = q.fontString(r, e._titleFontStyle, e._titleFontFamily),
              a = 0,
              o = n.length;
            a < o;
            ++a
          )
            i.fillText(n[a], t.x, t.y),
              (t.y += r + s),
              a + 1 === n.length && (t.y += e.titleMarginBottom - s);
        }
      },
      drawBody: function (i, n, a) {
        function o(t) {
          a.fillText(t, i.x + h, i.y), (i.y += s + e);
        }
        var r,
          s = n.bodyFontSize,
          e = n.bodySpacing,
          t = n._bodyAlign,
          l = n.body,
          d = n.displayColors,
          u = n.labelColors,
          h = 0,
          c = d ? Te(n, "left") : 0;
        (a.textAlign = t),
          (a.textBaseline = "top"),
          (a.font = q.fontString(s, n._bodyFontStyle, n._bodyFontFamily)),
          (i.x = Te(n, t));
        (a.fillStyle = n.bodyFontColor),
          q.each(n.beforeBody, o),
          (h = d && "right" !== t ? ("center" === t ? s / 2 + 1 : s + 2) : 0),
          q.each(l, function (t, e) {
            (r = n.labelTextColors[e]),
              (a.fillStyle = r),
              q.each(t.before, o),
              q.each(t.lines, function (t) {
                d &&
                  ((a.fillStyle = n.legendColorBackground),
                  a.fillRect(c, i.y, s, s),
                  (a.lineWidth = 1),
                  (a.strokeStyle = u[e].borderColor),
                  a.strokeRect(c, i.y, s, s),
                  (a.fillStyle = u[e].backgroundColor),
                  a.fillRect(c + 1, i.y + 1, s - 2, s - 2),
                  (a.fillStyle = r)),
                  o(t);
              }),
              q.each(t.after, o);
          }),
          (h = 0),
          q.each(n.afterBody, o),
          (i.y -= e);
      },
      drawFooter: function (e, i, n) {
        var t = i.footer;
        t.length &&
          ((e.x = Te(i, i._footerAlign)),
          (e.y += i.footerMarginTop),
          (n.textAlign = i._footerAlign),
          (n.textBaseline = "top"),
          (n.fillStyle = i.footerFontColor),
          (n.font = q.fontString(
            i.footerFontSize,
            i._footerFontStyle,
            i._footerFontFamily
          )),
          q.each(t, function (t) {
            n.fillText(t, e.x, e.y),
              (e.y += i.footerFontSize + i.footerSpacing);
          }));
      },
      drawBackground: function (t, e, i, n) {
        (i.fillStyle = e.backgroundColor),
          (i.strokeStyle = e.borderColor),
          (i.lineWidth = e.borderWidth);
        var a = e.xAlign,
          o = e.yAlign,
          r = t.x,
          s = t.y,
          l = n.width,
          d = n.height,
          u = e.cornerRadius;
        i.beginPath(),
          i.moveTo(r + u, s),
          "top" === o && this.drawCaret(t, n),
          i.lineTo(r + l - u, s),
          i.quadraticCurveTo(r + l, s, r + l, s + u),
          "center" === o && "right" === a && this.drawCaret(t, n),
          i.lineTo(r + l, s + d - u),
          i.quadraticCurveTo(r + l, s + d, r + l - u, s + d),
          "bottom" === o && this.drawCaret(t, n),
          i.lineTo(r + u, s + d),
          i.quadraticCurveTo(r, s + d, r, s + d - u),
          "center" === o && "left" === a && this.drawCaret(t, n),
          i.lineTo(r, s + u),
          i.quadraticCurveTo(r, s, r + u, s),
          i.closePath(),
          i.fill(),
          0 < e.borderWidth && i.stroke();
      },
      draw: function () {
        var t,
          e,
          i,
          n,
          a = this._chart.ctx,
          o = this._view;
        0 !== o.opacity &&
          ((t = { width: o.width, height: o.height }),
          (e = { x: o.x, y: o.y }),
          (i = Math.abs(o.opacity < 0.001) ? 0 : o.opacity),
          (n =
            o.title.length ||
            o.beforeBody.length ||
            o.body.length ||
            o.afterBody.length ||
            o.footer.length),
          this._options.enabled) &&
          n &&
          (a.save(),
          (a.globalAlpha = i),
          this.drawBackground(e, o, a, t),
          (e.y += o.yPadding),
          this.drawTitle(e, o, a),
          this.drawBody(e, o, a),
          this.drawFooter(e, o, a),
          a.restore());
      },
      handleEvent: function (t) {
        var e,
          i = this,
          n = i._options;
        return (
          (i._lastActive = i._lastActive || []),
          "mouseout" === t.type
            ? (i._active = [])
            : (i._active = i._chart.getElementsAtEventForMode(t, n.mode, n)),
          (e = !q.arrayEquals(i._active, i._lastActive)) &&
            ((i._lastActive = i._active), n.enabled || n.custom) &&
            ((i._eventPosition = { x: t.x, y: t.y }), i.update(!0), i.pivot()),
          e
        );
      },
    }),
    Re = ((Le.positioners = Ae), q.valueOrDefault);
  function Oe() {
    return q.merge({}, [].slice.call(arguments), {
      merger: function (t, e, i, n) {
        if ("xAxes" === t || "yAxes" === t) {
          var a,
            o,
            r,
            s = i[t].length;
          for (e[t] || (e[t] = []), a = 0; a < s; ++a)
            (r = i[t][a]),
              (o = Re(r.type, "xAxes" === t ? "category" : "linear")),
              a >= e[t].length && e[t].push({}),
              !e[t][a].type || (r.type && r.type !== e[t][a].type)
                ? q.merge(e[t][a], [Ie.getScaleDefaults(o), r])
                : q.merge(e[t][a], r);
        } else q._merger(t, e, i, n);
      },
    });
  }
  function ze() {
    return q.merge({}, [].slice.call(arguments), {
      merger: function (t, e, i, n) {
        var a = e[t] || {},
          o = i[t];
        "scales" === t
          ? (e[t] = Oe(a, o))
          : "scale" === t
          ? (e[t] = q.merge(a, [Ie.getScaleDefaults(o.type), o]))
          : q._merger(t, e, i, n);
      },
    });
  }
  function Be(t) {
    return "top" === t || "bottom" === t;
  }
  j._set("global", {
    elements: {},
    events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
    hover: {
      onHover: null,
      mode: "nearest",
      intersect: !0,
      animationDuration: 400,
    },
    onClick: null,
    maintainAspectRatio: !0,
    responsive: !0,
    responsiveAnimationDuration: 0,
  });
  function I(t, e) {
    return this.construct(t, e), this;
  }
  q.extend(I.prototype, {
    construct: function (t, e) {
      var i = this,
        n =
          (((n = (a = (a = e) || {}).data = a.data || {}).datasets =
            n.datasets || []),
          (n.labels = n.labels || []),
          (a.options = ze(j.global, j[a.type], a.options || {})),
          (e = a),
          Pe.acquireContext(t, e)),
        a = n && n.canvas,
        t = a && a.height,
        o = a && a.width;
      (i.id = q.uid()),
        (i.ctx = n),
        (i.canvas = a),
        (i.config = e),
        (i.width = o),
        (i.height = t),
        (i.aspectRatio = t ? o / t : null),
        (i.options = e.options),
        (i._bufferedRender = !1),
        ((i.chart = i).controller = i),
        (I.instances[i.id] = i),
        Object.defineProperty(i, "data", {
          get: function () {
            return i.config.data;
          },
          set: function (t) {
            i.config.data = t;
          },
        }),
        n && a
          ? (i.initialize(), i.update())
          : console.error(
              "Failed to create chart: can't acquire context from the given item"
            );
    },
    initialize: function () {
      var t = this;
      return (
        _.notify(t, "beforeInit"),
        q.retinaScale(t, t.options.devicePixelRatio),
        t.bindEvents(),
        t.options.responsive && t.resize(!0),
        t.ensureScalesHaveIDs(),
        t.buildOrUpdateScales(),
        t.initToolTip(),
        _.notify(t, "afterInit"),
        t
      );
    },
    clear: function () {
      return q.canvas.clear(this), this;
    },
    stop: function () {
      return Lt.cancelAnimation(this), this;
    },
    resize: function (t) {
      var e = this,
        i = e.options,
        n = e.canvas,
        a = (i.maintainAspectRatio && e.aspectRatio) || null,
        o = Math.max(0, Math.floor(q.getMaximumWidth(n))),
        a = Math.max(0, Math.floor(a ? o / a : q.getMaximumHeight(n)));
      (e.width === o && e.height === a) ||
        ((n.width = e.width = o),
        (n.height = e.height = a),
        (n.style.width = o + "px"),
        (n.style.height = a + "px"),
        q.retinaScale(e, i.devicePixelRatio),
        t) ||
        (_.notify(e, "resize", [(n = { width: o, height: a })]),
        i.onResize && i.onResize(e, n),
        e.stop(),
        e.update({ duration: i.responsiveAnimationDuration }));
    },
    ensureScalesHaveIDs: function () {
      var t = this.options,
        e = t.scales || {},
        t = t.scale;
      q.each(e.xAxes, function (t, e) {
        t.id = t.id || "x-axis-" + e;
      }),
        q.each(e.yAxes, function (t, e) {
          t.id = t.id || "y-axis-" + e;
        }),
        t && (t.id = t.id || "scale");
    },
    buildOrUpdateScales: function () {
      var r = this,
        t = r.options,
        s = r.scales || {},
        e = [],
        l = Object.keys(s).reduce(function (t, e) {
          return (t[e] = !1), t;
        }, {});
      t.scales &&
        (e = e.concat(
          (t.scales.xAxes || []).map(function (t) {
            return { options: t, dtype: "category", dposition: "bottom" };
          }),
          (t.scales.yAxes || []).map(function (t) {
            return { options: t, dtype: "linear", dposition: "left" };
          })
        )),
        t.scale &&
          e.push({
            options: t.scale,
            dtype: "radialLinear",
            isDefault: !0,
            dposition: "chartArea",
          }),
        q.each(e, function (t) {
          var e = t.options,
            i = e.id,
            n = Re(e.type, t.dtype),
            a =
              (Be(e.position) !== Be(t.dposition) && (e.position = t.dposition),
              (l[i] = !0),
              null);
          if (i in s && s[i].type === n)
            ((a = s[i]).options = e), (a.ctx = r.ctx), (a.chart = r);
          else {
            var o = Ie.getScaleConstructor(n);
            if (!o) return;
            (a = new o({ id: i, type: n, options: e, ctx: r.ctx, chart: r })),
              (s[a.id] = a);
          }
          a.mergeTicksOptions(), t.isDefault && (r.scale = a);
        }),
        q.each(l, function (t, e) {
          t || delete s[e];
        }),
        (r.scales = s),
        Ie.addScalesToLayout(this);
    },
    buildOrUpdateControllers: function () {
      var n = this,
        a = [];
      return (
        q.each(
          n.data.datasets,
          function (t, e) {
            var i = n.getDatasetMeta(e),
              t = t.type || n.config.type;
            if (
              (i.type &&
                i.type !== t &&
                (n.destroyDatasetMeta(e), (i = n.getDatasetMeta(e))),
              (i.type = t),
              i.controller)
            )
              i.controller.updateIndex(e), i.controller.linkScales();
            else {
              t = oe[i.type];
              if (void 0 === t)
                throw new Error('"' + i.type + '" is not a chart type.');
              (i.controller = new t(n, e)), a.push(i.controller);
            }
          },
          n
        ),
        a
      );
    },
    resetElements: function () {
      var i = this;
      q.each(
        i.data.datasets,
        function (t, e) {
          i.getDatasetMeta(e).controller.reset();
        },
        i
      );
    },
    reset: function () {
      this.resetElements(), this.tooltip.initialize();
    },
    update: function (t) {
      var e,
        i,
        n = this;
      (t && "object" == typeof t) || (t = { duration: t, lazy: arguments[1] }),
        (i = (e = n).options),
        q.each(e.scales, function (t) {
          M.removeBox(e, t);
        }),
        (i = ze(j.global, j[e.config.type], i)),
        (e.options = e.config.options = i),
        e.ensureScalesHaveIDs(),
        e.buildOrUpdateScales(),
        (e.tooltip._options = i.tooltips),
        e.tooltip.initialize(),
        _._invalidate(n),
        !1 !== _.notify(n, "beforeUpdate") &&
          ((n.tooltip._data = n.data),
          (i = n.buildOrUpdateControllers()),
          q.each(
            n.data.datasets,
            function (t, e) {
              n.getDatasetMeta(e).controller.buildOrUpdateElements();
            },
            n
          ),
          n.updateLayout(),
          n.options.animation &&
            n.options.animation.duration &&
            q.each(i, function (t) {
              t.reset();
            }),
          n.updateDatasets(),
          n.tooltip.initialize(),
          (n.lastActive = []),
          _.notify(n, "afterUpdate"),
          n._bufferedRender
            ? (n._bufferedRequest = {
                duration: t.duration,
                easing: t.easing,
                lazy: t.lazy,
              })
            : n.render(t));
    },
    updateLayout: function () {
      !1 !== _.notify(this, "beforeLayout") &&
        (M.update(this, this.width, this.height),
        _.notify(this, "afterScaleUpdate"),
        _.notify(this, "afterLayout"));
    },
    updateDatasets: function () {
      if (!1 !== _.notify(this, "beforeDatasetsUpdate")) {
        for (var t = 0, e = this.data.datasets.length; t < e; ++t)
          this.updateDataset(t);
        _.notify(this, "afterDatasetsUpdate");
      }
    },
    updateDataset: function (t) {
      var e = this.getDatasetMeta(t),
        t = { meta: e, index: t };
      !1 !== _.notify(this, "beforeDatasetUpdate", [t]) &&
        (e.controller.update(), _.notify(this, "afterDatasetUpdate", [t]));
    },
    render: function (t) {
      var e,
        i = this,
        n = i.options.animation,
        a = Re(
          (t =
            t && "object" == typeof t ? t : { duration: t, lazy: arguments[1] })
            .duration,
          n && n.duration
        ),
        o = t.lazy;
      if (!1 !== _.notify(i, "beforeRender"))
        return (
          (e = function (t) {
            _.notify(i, "afterRender"), q.callback(n && n.onComplete, [t], i);
          }),
          n && a
            ? ((t = new Ft({
                numSteps: a / 16.66,
                easing: t.easing || n.easing,
                render: function (t, e) {
                  var i = q.easing.effects[e.easing],
                    n = e.currentStep,
                    e = n / e.numSteps;
                  t.draw(i(e), e, n);
                },
                onAnimationProgress: n.onProgress,
                onAnimationComplete: e,
              })),
              Lt.addAnimation(i, t, a, o))
            : (i.draw(), e(new Ft({ numSteps: 0, chart: i }))),
          i
        );
    },
    draw: function (t) {
      var e = this;
      e.clear(),
        q.isNullOrUndef(t) && (t = 1),
        e.transition(t),
        e.width <= 0 ||
          e.height <= 0 ||
          (!1 !== _.notify(e, "beforeDraw", [t]) &&
            (q.each(
              e.boxes,
              function (t) {
                t.draw(e.chartArea);
              },
              e
            ),
            e.drawDatasets(t),
            e._drawTooltip(t),
            _.notify(e, "afterDraw", [t])));
    },
    transition: function (t) {
      for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e)
        this.isDatasetVisible(e) &&
          this.getDatasetMeta(e).controller.transition(t);
      this.tooltip.transition(t);
    },
    drawDatasets: function (t) {
      var e = this;
      if (!1 !== _.notify(e, "beforeDatasetsDraw", [t])) {
        for (var i = (e.data.datasets || []).length - 1; 0 <= i; --i)
          e.isDatasetVisible(i) && e.drawDataset(i, t);
        _.notify(e, "afterDatasetsDraw", [t]);
      }
    },
    drawDataset: function (t, e) {
      var i = this.getDatasetMeta(t),
        t = { meta: i, index: t, easingValue: e };
      !1 !== _.notify(this, "beforeDatasetDraw", [t]) &&
        (i.controller.draw(e), _.notify(this, "afterDatasetDraw", [t]));
    },
    _drawTooltip: function (t) {
      var e = this.tooltip,
        t = { tooltip: e, easingValue: t };
      !1 !== _.notify(this, "beforeTooltipDraw", [t]) &&
        (e.draw(), _.notify(this, "afterTooltipDraw", [t]));
    },
    getElementAtEvent: function (t) {
      return he.modes.single(this, t);
    },
    getElementsAtEvent: function (t) {
      return he.modes.label(this, t, { intersect: !0 });
    },
    getElementsAtXAxis: function (t) {
      return he.modes["x-axis"](this, t, { intersect: !0 });
    },
    getElementsAtEventForMode: function (t, e, i) {
      e = he.modes[e];
      return "function" == typeof e ? e(this, t, i) : [];
    },
    getDatasetAtEvent: function (t) {
      return he.modes.dataset(this, t, { intersect: !0 });
    },
    getDatasetMeta: function (t) {
      t = this.data.datasets[t];
      return (
        t._meta || (t._meta = {}),
        t._meta[this.id] ||
          (t._meta[this.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
          })
      );
    },
    getVisibleDatasetCount: function () {
      for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e)
        this.isDatasetVisible(e) && t++;
      return t;
    },
    isDatasetVisible: function (t) {
      var e = this.getDatasetMeta(t);
      return "boolean" == typeof e.hidden
        ? !e.hidden
        : !this.data.datasets[t].hidden;
    },
    generateLegend: function () {
      return this.options.legendCallback(this);
    },
    destroyDatasetMeta: function (t) {
      var e = this.id,
        t = this.data.datasets[t],
        i = t._meta && t._meta[e];
      i && (i.controller.destroy(), delete t._meta[e]);
    },
    destroy: function () {
      var t,
        e,
        i = this,
        n = i.canvas;
      for (i.stop(), t = 0, e = i.data.datasets.length; t < e; ++t)
        i.destroyDatasetMeta(t);
      n &&
        (i.unbindEvents(),
        q.canvas.clear(i),
        Pe.releaseContext(i.ctx),
        (i.canvas = null),
        (i.ctx = null)),
        _.notify(i, "destroy"),
        delete I.instances[i.id];
    },
    toBase64Image: function () {
      return this.canvas.toDataURL.apply(this.canvas, arguments);
    },
    initToolTip: function () {
      var t = this;
      t.tooltip = new Le(
        {
          _chart: t,
          _chartInstance: t,
          _data: t.data,
          _options: t.options.tooltips,
        },
        t
      );
    },
    bindEvents: function () {
      var e = this,
        i = (e._listeners = {}),
        n = function () {
          e.eventHandler.apply(e, arguments);
        };
      q.each(e.options.events, function (t) {
        Pe.addEventListener(e, t, n), (i[t] = n);
      }),
        e.options.responsive &&
          ((n = function () {
            e.resize();
          }),
          Pe.addEventListener(e, "resize", n),
          (i.resize = n));
    },
    unbindEvents: function () {
      var i = this,
        t = i._listeners;
      t &&
        (delete i._listeners,
        q.each(t, function (t, e) {
          Pe.removeEventListener(i, e, t);
        }));
    },
    updateHoverStyle: function (t, e, i) {
      for (
        var n,
          a = i ? "setHoverStyle" : "removeHoverStyle",
          o = 0,
          r = t.length;
        o < r;
        ++o
      )
        (n = t[o]) && this.getDatasetMeta(n._datasetIndex).controller[a](n);
    },
    eventHandler: function (t) {
      var e,
        i = this,
        n = i.tooltip;
      if (!1 !== _.notify(i, "beforeEvent", [t]))
        return (
          (i._bufferedRender = !0),
          (i._bufferedRequest = null),
          (e = i.handleEvent(t)),
          n && (e = n._start ? n.handleEvent(t) : e | n.handleEvent(t)),
          _.notify(i, "afterEvent", [t]),
          (n = i._bufferedRequest)
            ? i.render(n)
            : e &&
              !i.animating &&
              (i.stop(),
              i.render({
                duration: i.options.hover.animationDuration,
                lazy: !0,
              })),
          (i._bufferedRender = !1),
          (i._bufferedRequest = null),
          i
        );
    },
    handleEvent: function (t) {
      var e = this,
        i = e.options || {},
        n = i.hover;
      return (
        (e.lastActive = e.lastActive || []),
        "mouseout" === t.type
          ? (e.active = [])
          : (e.active = e.getElementsAtEventForMode(t, n.mode, n)),
        q.callback(i.onHover || i.hover.onHover, [t.native, e.active], e),
        ("mouseup" !== t.type && "click" !== t.type) ||
          (i.onClick && i.onClick.call(e, t.native, e.active)),
        e.lastActive.length && e.updateHoverStyle(e.lastActive, n.mode, !1),
        e.active.length && n.mode && e.updateHoverStyle(e.active, n.mode, !0),
        (i = !q.arrayEquals(e.active, e.lastActive)),
        (e.lastActive = e.active),
        i
      );
    },
  }),
    (I.instances = {});
  var A = I;
  function D() {
    throw new Error(
      "This method is not implemented: either no adapter can be found or an incomplete integration was provided."
    );
  }
  function Ne(t) {
    this.options = t || {};
  }
  ((I.Controller = I).types = {}),
    (q.configMerge = ze),
    (q.scaleMerge = Oe),
    q.extend(Ne.prototype, {
      formats: D,
      parse: D,
      format: D,
      add: D,
      diff: D,
      startOf: D,
      endOf: D,
      _create: function (t) {
        return t;
      },
    }),
    (Ne.override = function (t) {
      q.extend(Ne.prototype, t);
    });
  var We = { _date: Ne },
    m = {
      formatters: {
        values: function (t) {
          return q.isArray(t) ? t : "" + t;
        },
        linear: function (t, e, i) {
          var n = 3 < i.length ? i[2] - i[1] : i[1] - i[0],
            n =
              (1 < Math.abs(n) &&
                t !== Math.floor(t) &&
                (n = t - Math.floor(t)),
              q.log10(Math.abs(n)));
          return 0 !== t
            ? Math.max(Math.abs(i[0]), Math.abs(i[i.length - 1])) < 1e-4
              ? ((i = q.log10(Math.abs(t))),
                t.toExponential(Math.floor(i) - Math.floor(n)))
              : ((i = -1 * Math.floor(n)),
                (i = Math.max(Math.min(i, 20), 0)),
                t.toFixed(i))
            : "0";
        },
        logarithmic: function (t, e, i) {
          var n = t / Math.pow(10, Math.floor(q.log10(t)));
          return 0 === t
            ? "0"
            : 1 == n || 2 == n || 5 == n || 0 === e || e === i.length - 1
            ? t.toExponential()
            : "";
        },
      },
    },
    Ve = q.valueOrDefault,
    Ee = q.valueAtIndexOrDefault;
  function He(t) {
    for (var e = [], i = 0, n = t.length; i < n; ++i) e.push(t[i].label);
    return e;
  }
  function je(t, e, i) {
    return q.isArray(e) ? q.longestText(t, i, e) : t.measureText(e).width;
  }
  j._set("scale", {
    display: !0,
    position: "left",
    offset: !1,
    gridLines: {
      display: !0,
      color: "rgba(0, 0, 0, 0.1)",
      lineWidth: 1,
      drawBorder: !0,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickMarkLength: 10,
      zeroLineWidth: 1,
      zeroLineColor: "rgba(0,0,0,0.25)",
      zeroLineBorderDash: [],
      zeroLineBorderDashOffset: 0,
      offsetGridLines: !1,
      borderDash: [],
      borderDashOffset: 0,
    },
    scaleLabel: {
      display: !1,
      labelString: "",
      padding: { top: 4, bottom: 4 },
    },
    ticks: {
      beginAtZero: !1,
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      padding: 0,
      reverse: !1,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 0,
      labelOffset: 0,
      callback: m.formatters.values,
      minor: {},
      major: {},
    },
  });
  var T = t.extend({
      getPadding: function () {
        return {
          left: this.paddingLeft || 0,
          top: this.paddingTop || 0,
          right: this.paddingRight || 0,
          bottom: this.paddingBottom || 0,
        };
      },
      getTicks: function () {
        return this._ticks;
      },
      mergeTicksOptions: function () {
        var t,
          e = this.options.ticks;
        for (t in (!1 === e.minor && (e.minor = { display: !1 }),
        !1 === e.major && (e.major = { display: !1 }),
        e))
          "major" !== t &&
            "minor" !== t &&
            (void 0 === e.minor[t] && (e.minor[t] = e[t]),
            void 0 === e.major[t]) &&
            (e.major[t] = e[t]);
      },
      beforeUpdate: function () {
        q.callback(this.options.beforeUpdate, [this]);
      },
      update: function (t, e, i) {
        var n,
          a,
          o,
          r,
          s,
          l,
          d = this;
        for (
          d.beforeUpdate(),
            d.maxWidth = t,
            d.maxHeight = e,
            d.margins = q.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i),
            d._maxLabelLines = 0,
            d.longestLabelWidth = 0,
            d.longestTextCache = d.longestTextCache || {},
            d.beforeSetDimensions(),
            d.setDimensions(),
            d.afterSetDimensions(),
            d.beforeDataLimits(),
            d.determineDataLimits(),
            d.afterDataLimits(),
            d.beforeBuildTicks(),
            s = d.buildTicks() || [],
            s = d.afterBuildTicks(s) || s,
            d.beforeTickToLabelConversion(),
            o = d.convertTicksToLabels(s) || d.ticks,
            d.afterTickToLabelConversion(),
            n = 0,
            a = (d.ticks = o).length;
          n < a;
          ++n
        )
          (r = o[n]),
            (l = s[n]) ? (l.label = r) : s.push((l = { label: r, major: !1 }));
        return (
          (d._ticks = s),
          d.beforeCalculateTickRotation(),
          d.calculateTickRotation(),
          d.afterCalculateTickRotation(),
          d.beforeFit(),
          d.fit(),
          d.afterFit(),
          d.afterUpdate(),
          d.minSize
        );
      },
      afterUpdate: function () {
        q.callback(this.options.afterUpdate, [this]);
      },
      beforeSetDimensions: function () {
        q.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var t = this;
        t.isHorizontal()
          ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
          : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
          (t.paddingLeft = 0),
          (t.paddingTop = 0),
          (t.paddingRight = 0),
          (t.paddingBottom = 0);
      },
      afterSetDimensions: function () {
        q.callback(this.options.afterSetDimensions, [this]);
      },
      beforeDataLimits: function () {
        q.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: q.noop,
      afterDataLimits: function () {
        q.callback(this.options.afterDataLimits, [this]);
      },
      beforeBuildTicks: function () {
        q.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: q.noop,
      afterBuildTicks: function (t) {
        var e = this;
        return q.isArray(t) && t.length
          ? q.callback(e.options.afterBuildTicks, [e, t])
          : ((e.ticks =
              q.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks),
            t);
      },
      beforeTickToLabelConversion: function () {
        q.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var t = this.options.ticks;
        this.ticks = this.ticks.map(t.userCallback || t.callback, this);
      },
      afterTickToLabelConversion: function () {
        q.callback(this.options.afterTickToLabelConversion, [this]);
      },
      beforeCalculateTickRotation: function () {
        q.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var t = this,
          e = t.ctx,
          i = t.options.ticks,
          n = He(t._ticks),
          a = q.options._parseFont(i),
          o = ((e.font = a.string), i.minRotation || 0);
        if (n.length && t.options.display && t.isHorizontal())
          for (
            var r = q.longestText(e, a.string, n, t.longestTextCache),
              s = r,
              l = t.getPixelForTick(1) - t.getPixelForTick(0) - 6;
            l < s && o < i.maxRotation;

          ) {
            var d = q.toRadians(o),
              u = Math.cos(d);
            if (Math.sin(d) * r > t.maxHeight) {
              o--;
              break;
            }
            o++, (s = u * r);
          }
        t.labelRotation = o;
      },
      afterCalculateTickRotation: function () {
        q.callback(this.options.afterCalculateTickRotation, [this]);
      },
      beforeFit: function () {
        q.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var t,
          e,
          i = this,
          n = (i.minSize = { width: 0, height: 0 }),
          a = He(i._ticks),
          o = i.options,
          r = o.ticks,
          s = o.scaleLabel,
          l = o.gridLines,
          d = i._isVisible(),
          u = o.position,
          h = i.isHorizontal(),
          c = q.options._parseFont,
          f = c(r),
          o = o.gridLines.tickMarkLength;
        (n.width = h
          ? i.isFullWidth()
            ? i.maxWidth - i.margins.left - i.margins.right
            : i.maxWidth
          : d && l.drawTicks
          ? o
          : 0),
          (n.height = h ? (d && l.drawTicks ? o : 0) : i.maxHeight),
          s.display &&
            d &&
            ((l = c(s)),
            (o = q.options.toPadding(s.padding)),
            (c = l.lineHeight + o.height),
            h ? (n.height += c) : (n.width += c)),
          r.display &&
            d &&
            ((s = q.longestText(i.ctx, f.string, a, i.longestTextCache)),
            (l = q.numberOfLabelLines(a)),
            (o = 0.5 * f.size),
            (c = i.options.ticks.padding),
            (i._maxLabelLines = l),
            (i.longestLabelWidth = s),
            h
              ? ((d = q.toRadians(i.labelRotation)),
                (h = Math.cos(d)),
                (d = Math.sin(d) * s + f.lineHeight * l + o),
                (n.height = Math.min(i.maxHeight, n.height + d + c)),
                (i.ctx.font = f.string),
                (l = je(i.ctx, a[0], f.string)),
                (d = je(i.ctx, a[a.length - 1], f.string)),
                (e = i.getPixelForTick(0) - i.left),
                (a = i.right - i.getPixelForTick(a.length - 1)),
                (u =
                  0 !== i.labelRotation
                    ? ((t = "bottom" === u ? h * l : h * o),
                      "bottom" === u ? h * o : h * d)
                    : ((t = l / 2), d / 2)),
                (i.paddingLeft = Math.max(t - e, 0) + 3),
                (i.paddingRight = Math.max(u - a, 0) + 3))
              : (r.mirror ? (s = 0) : (s += c + o),
                (n.width = Math.min(i.maxWidth, n.width + s)),
                (i.paddingTop = f.size / 2),
                (i.paddingBottom = f.size / 2))),
          i.handleMargins(),
          (i.width = n.width),
          (i.height = n.height);
      },
      handleMargins: function () {
        var t = this;
        t.margins &&
          ((t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0)),
          (t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0)),
          (t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0)),
          (t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)));
      },
      afterFit: function () {
        q.callback(this.options.afterFit, [this]);
      },
      isHorizontal: function () {
        return (
          "top" === this.options.position || "bottom" === this.options.position
        );
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      getRightValue: function (t) {
        if (q.isNullOrUndef(t)) return NaN;
        if (("number" == typeof t || t instanceof Number) && !isFinite(t))
          return NaN;
        if (t)
          if (this.isHorizontal()) {
            if (void 0 !== t.x) return this.getRightValue(t.x);
          } else if (void 0 !== t.y) return this.getRightValue(t.y);
        return t;
      },
      getLabelForIndex: q.noop,
      getPixelForValue: q.noop,
      getValueForPixel: q.noop,
      getPixelForTick: function (t) {
        var e,
          i,
          n = this,
          a = n.options.offset;
        return n.isHorizontal()
          ? ((i =
              (e =
                (n.width - (n.paddingLeft + n.paddingRight)) /
                Math.max(n._ticks.length - (a ? 0 : 1), 1)) *
                t +
              n.paddingLeft),
            a && (i += e / 2),
            n.left + i + (n.isFullWidth() ? n.margins.left : 0))
          : ((a = n.height - (n.paddingTop + n.paddingBottom)),
            n.top + t * (a / (n._ticks.length - 1)));
      },
      getPixelForDecimal: function (t) {
        var e,
          i = this;
        return i.isHorizontal()
          ? ((e =
              (i.width - (i.paddingLeft + i.paddingRight)) * t + i.paddingLeft),
            i.left + e + (i.isFullWidth() ? i.margins.left : 0))
          : i.top + t * i.height;
      },
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var t = this.min,
          e = this.max;
        return this.beginAtZero
          ? 0
          : t < 0 && e < 0
          ? e
          : 0 < t && 0 < e
          ? t
          : 0;
      },
      _autoSkip: function (t) {
        var e,
          i,
          n = this,
          a = n.isHorizontal(),
          o = n.options.ticks.minor,
          r = t.length,
          s = !1,
          o = o.maxTicksLimit,
          l = n._tickSize() * (r - 1),
          a = a
            ? n.width - (n.paddingLeft + n.paddingRight)
            : n.height - (n.paddingTop + n.PaddingBottom),
          d = [];
        for (
          a < l && (s = 1 + Math.floor(l / a)),
            o < r && (s = Math.max(s, 1 + Math.floor(r / o))),
            e = 0;
          e < r;
          e++
        )
          (i = t[e]), 1 < s && 0 < e % s && delete i.label, d.push(i);
        return d;
      },
      _tickSize: function () {
        var t = this,
          e = t.isHorizontal(),
          i = t.options.ticks.minor,
          n = q.toRadians(t.labelRotation),
          a = Math.abs(Math.cos(n)),
          n = Math.abs(Math.sin(n)),
          o = i.autoSkipPadding || 0,
          r = t.longestLabelWidth + o || 0,
          i = q.options._parseFont(i),
          t = t._maxLabelLines * i.lineHeight + o || 0;
        return e
          ? r * n < t * a
            ? r / a
            : t / n
          : t * n < r * a
          ? t / a
          : r / n;
      },
      _isVisible: function () {
        var t,
          e,
          i,
          n = this.chart,
          a = this.options.display;
        if ("auto" !== a) return !!a;
        for (t = 0, e = n.data.datasets.length; t < e; ++t)
          if (
            n.isDatasetVisible(t) &&
            ((i = n.getDatasetMeta(t)).xAxisID === this.id ||
              i.yAxisID === this.id)
          )
            return !0;
        return !1;
      },
      draw: function (_) {
        var t,
          C,
          S,
          r,
          s,
          P,
          e,
          I,
          A,
          D,
          T,
          i,
          l,
          d,
          F,
          v,
          x,
          L,
          R,
          O,
          n,
          a,
          H,
          z,
          B,
          N,
          y,
          o,
          u,
          h,
          c,
          f,
          g,
          p,
          m,
          b,
          W,
          V = this,
          E = V.options;
        V._isVisible() &&
          ((S = V.chart),
          (r = V.ctx),
          (a = j.global.defaultFontColor),
          (s = E.ticks.minor),
          (n = E.ticks.major || s),
          (P = E.gridLines),
          (e = E.scaleLabel),
          (I = E.position),
          (A = 0 !== V.labelRotation),
          (D = s.mirror),
          (T = V.isHorizontal()),
          (b = q.options._parseFont),
          (i =
            s.display && s.autoSkip ? V._autoSkip(V.getTicks()) : V.getTicks()),
          (l = Ve(s.fontColor, a)),
          (d = b(s)),
          (F = d.lineHeight),
          (v = Ve(n.fontColor, a)),
          (x = b(n)),
          (L = s.padding),
          (R = s.labelOffset),
          (O = P.drawTicks ? P.tickMarkLength : 0),
          (n = Ve(e.fontColor, a)),
          (a = b(e)),
          (b = q.options.toPadding(e.padding)),
          (H = q.toRadians(V.labelRotation)),
          (z = []),
          (B = P.drawBorder ? Ee(P.lineWidth, 0, 0) : 0),
          (N = q._alignPixel),
          (W =
            "top" === I
              ? ((t = N(S, V.bottom, B)), (C = V.bottom - O), t - B / 2)
              : "bottom" === I
              ? ((t = N(S, V.top, B)), (C = t + B / 2), V.top + O)
              : "left" === I
              ? ((t = N(S, V.right, B)), (C = V.right - O), t - B / 2)
              : ((t = N(S, V.left, B)), (C = t + B / 2), V.left + O)),
          q.each(i, function (t, e) {
            var i,
              n,
              a,
              o,
              r,
              s,
              l,
              d,
              u,
              h,
              c,
              f,
              g,
              p,
              m,
              b,
              v,
              x,
              y,
              k,
              M,
              w;
            q.isNullOrUndef(t.label) ||
              ((b = t.label),
              (v =
                e === V.zeroLineIndex && E.offset === P.offsetGridLines
                  ? ((i = P.zeroLineWidth),
                    (n = P.zeroLineColor),
                    (a = P.zeroLineBorderDash || []),
                    P.zeroLineBorderDashOffset || 0)
                  : ((i = Ee(P.lineWidth, e)),
                    (n = Ee(P.color, e)),
                    (a = P.borderDash || []),
                    P.borderDashOffset || 0)),
              (x = q.isArray(b) ? b.length : 1),
              (y = V),
              (k = e),
              (M = P.offsetGridLines),
              (w = y.getPixelForTick(k)),
              M &&
                (1 === y.getTicks().length
                  ? (w -= y.isHorizontal()
                      ? Math.max(w - y.left, y.right - w)
                      : Math.max(w - y.top, y.bottom - w))
                  : (w -=
                      0 === k
                        ? (y.getPixelForTick(1) - w) / 2
                        : (w - y.getPixelForTick(k - 1)) / 2)),
              (M = w),
              T
                ? ((y = O + L),
                  M < V.left - 1e-7 && (n = "rgba(0,0,0,0)"),
                  (o = s = d = h = N(S, M, i)),
                  (r = C),
                  (l = W),
                  (f = V.getPixelForTick(e) + R),
                  (g =
                    "top" === I
                      ? ((u = N(S, _.top, B) + B / 2),
                        (c = _.bottom),
                        (p = ((A ? 1 : 0.5) - x) * F),
                        (m = A ? "left" : "center"),
                        V.bottom - y)
                      : ((u = _.top),
                        (c = N(S, _.bottom, B) - B / 2),
                        (p = (A ? 0 : 0.5) * F),
                        (m = A ? "right" : "center"),
                        V.top + y)))
                : ((k = (D ? 0 : O) + L),
                  M < V.top - 1e-7 && (n = "rgba(0,0,0,0)"),
                  (o = C),
                  (s = W),
                  (r = l = u = c = N(S, M, i)),
                  (g = V.getPixelForTick(e) + R),
                  (p = ((1 - x) * F) / 2),
                  (f =
                    "left" === I
                      ? ((d = N(S, _.left, B) + B / 2),
                        (h = _.right),
                        (m = D ? "left" : "right"),
                        V.right - k)
                      : ((d = _.left),
                        (h = N(S, _.right, B) - B / 2),
                        (m = D ? "right" : "left"),
                        V.left + k))),
              z.push({
                tx1: o,
                ty1: r,
                tx2: s,
                ty2: l,
                x1: d,
                y1: u,
                x2: h,
                y2: c,
                labelX: f,
                labelY: g,
                glWidth: i,
                glColor: n,
                glBorderDash: a,
                glBorderDashOffset: v,
                rotation: -1 * H,
                label: b,
                major: t.major,
                textOffset: p,
                textAlign: m,
              }));
          }),
          q.each(z, function (t) {
            var e = t.glWidth,
              i = t.glColor;
            if (
              (P.display &&
                e &&
                i &&
                (r.save(),
                (r.lineWidth = e),
                (r.strokeStyle = i),
                r.setLineDash &&
                  (r.setLineDash(t.glBorderDash),
                  (r.lineDashOffset = t.glBorderDashOffset)),
                r.beginPath(),
                P.drawTicks && (r.moveTo(t.tx1, t.ty1), r.lineTo(t.tx2, t.ty2)),
                P.drawOnChartArea &&
                  (r.moveTo(t.x1, t.y1), r.lineTo(t.x2, t.y2)),
                r.stroke(),
                r.restore()),
              s.display)
            ) {
              r.save(),
                r.translate(t.labelX, t.labelY),
                r.rotate(t.rotation),
                (r.font = (t.major ? x : d).string),
                (r.fillStyle = t.major ? v : l),
                (r.textBaseline = "middle"),
                (r.textAlign = t.textAlign);
              var n = t.label,
                a = t.textOffset;
              if (q.isArray(n))
                for (var o = 0; o < n.length; ++o)
                  r.fillText("" + n[o], 0, a), (a += F);
              else r.fillText(n, 0, a);
              r.restore();
            }
          }),
          e.display &&
            ((h = 0),
            (m = a.lineHeight / 2),
            T
              ? ((o = V.left + (V.right - V.left) / 2),
                (u =
                  "bottom" === I ? V.bottom - m - b.bottom : V.top + m + b.top))
              : ((o = (y = "left" === I)
                  ? V.left + m + b.top
                  : V.right - m - b.top),
                (u = V.top + (V.bottom - V.top) / 2),
                (h = y ? -0.5 * Math.PI : 0.5 * Math.PI)),
            r.save(),
            r.translate(o, u),
            r.rotate(h),
            (r.textAlign = "center"),
            (r.textBaseline = "middle"),
            (r.fillStyle = n),
            (r.font = a.string),
            r.fillText(e.labelString, 0, 0),
            r.restore()),
          B) &&
          ((m = B),
          (b = Ee(P.lineWidth, i.length - 1, 0)),
          T
            ? ((c = N(S, V.left, m) - m / 2),
              (f = N(S, V.right, b) + b / 2),
              (g = p = t))
            : ((g = N(S, V.top, m) - m / 2),
              (p = N(S, V.bottom, b) + b / 2),
              (c = f = t)),
          (r.lineWidth = B),
          (r.strokeStyle = Ee(P.color, 0)),
          r.beginPath(),
          r.moveTo(c, g),
          r.lineTo(f, p),
          r.stroke());
      },
    }),
    y = T.extend({
      getLabels: function () {
        var t = this.chart.data;
        return (
          this.options.labels ||
          (this.isHorizontal() ? t.xLabels : t.yLabels) ||
          t.labels
        );
      },
      determineDataLimits: function () {
        var t,
          e = this,
          i = e.getLabels();
        (e.minIndex = 0),
          (e.maxIndex = i.length - 1),
          void 0 !== e.options.ticks.min &&
            ((t = i.indexOf(e.options.ticks.min)),
            (e.minIndex = -1 !== t ? t : e.minIndex)),
          void 0 !== e.options.ticks.max &&
            ((t = i.indexOf(e.options.ticks.max)),
            (e.maxIndex = -1 !== t ? t : e.maxIndex)),
          (e.min = i[e.minIndex]),
          (e.max = i[e.maxIndex]);
      },
      buildTicks: function () {
        var t = this,
          e = t.getLabels();
        t.ticks =
          0 === t.minIndex && t.maxIndex === e.length - 1
            ? e
            : e.slice(t.minIndex, t.maxIndex + 1);
      },
      getLabelForIndex: function (t, e) {
        var i = this,
          n = i.chart;
        return n.getDatasetMeta(e).controller._getValueScaleId() === i.id
          ? i.getRightValue(n.data.datasets[e].data[t])
          : i.ticks[t - i.minIndex];
      },
      getPixelForValue: function (t, e) {
        var i,
          n = this,
          a = n.options.offset,
          o = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1);
        return (
          (void 0 !== (i = null != t ? (n.isHorizontal() ? t.x : t.y) : i) ||
            (void 0 !== t && isNaN(e))) &&
            ((t = i || t), (e = -1 !== (i = n.getLabels().indexOf(t)) ? i : e)),
          n.isHorizontal()
            ? ((i = (t = n.width / o) * (e - n.minIndex)),
              a && (i += t / 2),
              n.left + i)
            : ((i = (t = n.height / o) * (e - n.minIndex)),
              a && (i += t / 2),
              n.top + i)
        );
      },
      getPixelForTick: function (t) {
        return this.getPixelForValue(this.ticks[t], t + this.minIndex, null);
      },
      getValueForPixel: function (t) {
        var e = this,
          i = e.options.offset,
          n = Math.max(e._ticks.length - (i ? 0 : 1), 1),
          a = e.isHorizontal(),
          n = (a ? e.width : e.height) / n;
        return (
          (t -= a ? e.left : e.top),
          i && (t -= n / 2),
          (t <= 0 ? 0 : Math.round(t / n)) + e.minIndex
        );
      },
      getBasePixel: function () {
        return this.bottom;
      },
    }),
    ee = ((y._defaults = { position: "bottom" }), q.noop),
    F = q.isNullOrUndef,
    qe = T.extend({
      getRightValue: function (t) {
        return "string" == typeof t
          ? +t
          : T.prototype.getRightValue.call(this, t);
      },
      handleTickRangeOptions: function () {
        var t = this,
          e = t.options.ticks,
          i =
            (e.beginAtZero &&
              ((i = q.sign(t.min)),
              (n = q.sign(t.max)),
              i < 0 && n < 0 ? (t.max = 0) : 0 < i && 0 < n && (t.min = 0)),
            void 0 !== e.min || void 0 !== e.suggestedMin),
          n = void 0 !== e.max || void 0 !== e.suggestedMax;
        void 0 !== e.min
          ? (t.min = e.min)
          : void 0 !== e.suggestedMin &&
            (null === t.min
              ? (t.min = e.suggestedMin)
              : (t.min = Math.min(t.min, e.suggestedMin))),
          void 0 !== e.max
            ? (t.max = e.max)
            : void 0 !== e.suggestedMax &&
              (null === t.max
                ? (t.max = e.suggestedMax)
                : (t.max = Math.max(t.max, e.suggestedMax))),
          i != n &&
            t.min >= t.max &&
            (i ? (t.max = t.min + 1) : (t.min = t.max - 1)),
          t.min === t.max && (t.max++, e.beginAtZero || t.min--);
      },
      getTickLimit: function () {
        var t,
          e = this.options.ticks,
          i = e.stepSize,
          e = e.maxTicksLimit;
        return (
          i
            ? (t = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1)
            : ((t = this._computeTickLimit()), (e = e || 11)),
          (t = e ? Math.min(e, t) : t)
        );
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: ee,
      buildTicks: function () {
        var g = this,
          t = g.options.ticks,
          e = g.getTickLimit(),
          p = {
            maxTicks: Math.max(2, e),
            min: t.min,
            max: t.max,
            precision: t.precision,
            stepSize: q.valueOrDefault(t.fixedStepSize, t.stepSize),
          },
          e = (g.ticks = (function () {
            var t,
              e,
              i,
              n = [],
              a = p.stepSize,
              o = a || 1,
              r = p.maxTicks - 1,
              s = p.min,
              l = p.max,
              d = p.precision,
              u = g.min,
              h = g.max,
              c = q.niceNum((h - u) / r / o) * o;
            if (c < 1e-14 && F(s) && F(l)) return [u, h];
            (i = Math.ceil(h / c) - Math.floor(u / c)) > r &&
              (c = q.niceNum((i * c) / r / o) * o),
              a || F(d)
                ? (t = Math.pow(10, q._decimalPlaces(c)))
                : ((t = Math.pow(10, d)), (c = Math.ceil(c * t) / t)),
              (e = Math.floor(u / c) * c),
              (r = Math.ceil(h / c) * c),
              a &&
                (!F(s) && q.almostWhole(s / c, c / 1e3) && (e = s), !F(l)) &&
                q.almostWhole(l / c, c / 1e3) &&
                (r = l),
              (i = q.almostEquals((i = (r - e) / c), Math.round(i), c / 1e3)
                ? Math.round(i)
                : Math.ceil(i)),
              (e = Math.round(e * t) / t),
              (r = Math.round(r * t) / t),
              n.push(F(s) ? e : s);
            for (var f = 1; f < i; ++f) n.push(Math.round((e + f * c) * t) / t);
            return n.push(F(l) ? r : l), n;
          })());
        g.handleDirectionalChanges(),
          (g.max = q.max(e)),
          (g.min = q.min(e)),
          t.reverse
            ? (e.reverse(), (g.start = g.max), (g.end = g.min))
            : ((g.start = g.min), (g.end = g.max));
      },
      convertTicksToLabels: function () {
        var t = this;
        (t.ticksAsNumbers = t.ticks.slice()),
          (t.zeroLineIndex = t.ticks.indexOf(0)),
          T.prototype.convertTicksToLabels.call(t);
      },
    }),
    ae = { position: "left", ticks: { callback: m.formatters.linear } },
    Qt = qe.extend({
      determineDataLimits: function () {
        var r = this,
          s = r.options,
          l = r.chart,
          t = l.data.datasets,
          e = r.isHorizontal();
        function d(t) {
          return e ? t.xAxisID === r.id : t.yAxisID === r.id;
        }
        (r.min = null), (r.max = null);
        var u,
          n = s.stacked;
        void 0 === n &&
          q.each(t, function (t, e) {
            var i;
            n ||
              ((i = l.getDatasetMeta(e)),
              l.isDatasetVisible(e) && d(i) && void 0 !== i.stack && (n = !0));
          }),
          s.stacked || n
            ? ((u = {}),
              q.each(t, function (t, e) {
                var i = l.getDatasetMeta(e),
                  n = [
                    i.type,
                    void 0 === s.stacked && void 0 === i.stack ? e : "",
                    i.stack,
                  ].join("."),
                  a =
                    (void 0 === u[n] &&
                      (u[n] = { positiveValues: [], negativeValues: [] }),
                    u[n].positiveValues),
                  o = u[n].negativeValues;
                l.isDatasetVisible(e) &&
                  d(i) &&
                  q.each(t.data, function (t, e) {
                    t = +r.getRightValue(t);
                    isNaN(t) ||
                      i.data[e].hidden ||
                      ((a[e] = a[e] || 0),
                      (o[e] = o[e] || 0),
                      s.relativePoints
                        ? (a[e] = 100)
                        : t < 0
                        ? (o[e] += t)
                        : (a[e] += t));
                  });
              }),
              q.each(u, function (t) {
                var t = t.positiveValues.concat(t.negativeValues),
                  e = q.min(t),
                  t = q.max(t);
                (r.min = null === r.min ? e : Math.min(r.min, e)),
                  (r.max = null === r.max ? t : Math.max(r.max, t));
              }))
            : q.each(t, function (t, e) {
                var i = l.getDatasetMeta(e);
                l.isDatasetVisible(e) &&
                  d(i) &&
                  q.each(t.data, function (t, e) {
                    t = +r.getRightValue(t);
                    !isNaN(t) &&
                      !i.data[e].hidden &&
                      ((null === r.min || t < r.min) && (r.min = t),
                      null === r.max || t > r.max) &&
                      (r.max = t);
                  });
              }),
          (r.min = isFinite(r.min) && !isNaN(r.min) ? r.min : 0),
          (r.max = isFinite(r.max) && !isNaN(r.max) ? r.max : 1),
          this.handleTickRangeOptions();
      },
      _computeTickLimit: function () {
        var t;
        return this.isHorizontal()
          ? Math.ceil(this.width / 40)
          : ((t = q.options._parseFont(this.options.ticks)),
            Math.ceil(this.height / t.lineHeight));
      },
      handleDirectionalChanges: function () {
        this.isHorizontal() || this.ticks.reverse();
      },
      getLabelForIndex: function (t, e) {
        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
      },
      getPixelForValue: function (t) {
        var e = this,
          i = e.start,
          t = +e.getRightValue(t),
          n = e.end - i;
        return e.isHorizontal()
          ? e.left + (e.width / n) * (t - i)
          : e.bottom - (e.height / n) * (t - i);
      },
      getValueForPixel: function (t) {
        var e = this,
          i = e.isHorizontal(),
          n = i ? e.width : e.height,
          i = (i ? t - e.left : e.bottom - t) / n;
        return e.start + (e.end - e.start) * i;
      },
      getPixelForTick: function (t) {
        return this.getPixelForValue(this.ticksAsNumbers[t]);
      },
    }),
    Ye = ((Qt._defaults = ae), q.valueOrDefault),
    a = { position: "left", ticks: { callback: m.formatters.logarithmic } };
  function Ue(t, e) {
    return q.isFinite(t) && 0 <= t ? t : e;
  }
  var o = T.extend({
      determineDataLimits: function () {
        var o = this,
          i = o.options,
          r = o.chart,
          t = r.data.datasets,
          e = o.isHorizontal();
        function s(t) {
          return e ? t.xAxisID === o.id : t.yAxisID === o.id;
        }
        (o.min = null), (o.max = null), (o.minNotZero = null);
        var l,
          n = i.stacked;
        void 0 === n &&
          q.each(t, function (t, e) {
            var i;
            n ||
              ((i = r.getDatasetMeta(e)),
              r.isDatasetVisible(e) && s(i) && void 0 !== i.stack && (n = !0));
          }),
          i.stacked || n
            ? ((l = {}),
              q.each(t, function (t, e) {
                var n = r.getDatasetMeta(e),
                  a = [
                    n.type,
                    void 0 === i.stacked && void 0 === n.stack ? e : "",
                    n.stack,
                  ].join(".");
                r.isDatasetVisible(e) &&
                  s(n) &&
                  (void 0 === l[a] && (l[a] = []),
                  q.each(t.data, function (t, e) {
                    var i = l[a],
                      t = +o.getRightValue(t);
                    isNaN(t) ||
                      n.data[e].hidden ||
                      t < 0 ||
                      ((i[e] = i[e] || 0), (i[e] += t));
                  }));
              }),
              q.each(l, function (t) {
                var e;
                0 < t.length &&
                  ((e = q.min(t)),
                  (t = q.max(t)),
                  (o.min = null === o.min ? e : Math.min(o.min, e)),
                  (o.max = null === o.max ? t : Math.max(o.max, t)));
              }))
            : q.each(t, function (t, e) {
                var i = r.getDatasetMeta(e);
                r.isDatasetVisible(e) &&
                  s(i) &&
                  q.each(t.data, function (t, e) {
                    t = +o.getRightValue(t);
                    isNaN(t) ||
                      i.data[e].hidden ||
                      t < 0 ||
                      ((null === o.min || t < o.min) && (o.min = t),
                      (null === o.max || t > o.max) && (o.max = t),
                      0 != t &&
                        (null === o.minNotZero || t < o.minNotZero) &&
                        (o.minNotZero = t));
                  });
              }),
          this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var t = this,
          e = t.options.ticks;
        (t.min = Ue(e.min, t.min)),
          (t.max = Ue(e.max, t.max)),
          t.min === t.max &&
            (0 !== t.min && null !== t.min
              ? ((t.min = Math.pow(10, Math.floor(q.log10(t.min)) - 1)),
                (t.max = Math.pow(10, Math.floor(q.log10(t.max)) + 1)))
              : ((t.min = 1), (t.max = 10))),
          null === t.min &&
            (t.min = Math.pow(10, Math.floor(q.log10(t.max)) - 1)),
          null === t.max &&
            (t.max =
              0 !== t.min ? Math.pow(10, Math.floor(q.log10(t.min)) + 1) : 10),
          null === t.minNotZero &&
            (0 < t.min
              ? (t.minNotZero = t.min)
              : t.max < 1
              ? (t.minNotZero = Math.pow(10, Math.floor(q.log10(t.max))))
              : (t.minNotZero = 1));
      },
      buildTicks: function () {
        var t = this,
          e = t.options.ticks,
          i = !t.isHorizontal(),
          n = { min: Ue(e.min), max: Ue(e.max) },
          n = (t.ticks = (function (t, e) {
            for (
              var i,
                n,
                a = [],
                o = Ye(t.min, Math.pow(10, Math.floor(q.log10(e.min)))),
                r = Math.floor(q.log10(e.max)),
                s = Math.ceil(e.max / Math.pow(10, r)),
                l =
                  (0 === o
                    ? ((i = Math.floor(q.log10(e.minNotZero))),
                      (n = Math.floor(e.minNotZero / Math.pow(10, i))),
                      a.push(o),
                      (o = n * Math.pow(10, i)))
                    : ((i = Math.floor(q.log10(o))),
                      (n = Math.floor(o / Math.pow(10, i)))),
                  i < 0 ? Math.pow(10, Math.abs(i)) : 1);
              a.push(o),
                10 == ++n && ((n = 1), (l = 0 <= ++i ? 1 : l)),
                (o = Math.round(n * Math.pow(10, i) * l) / l),
                i < r || (i === r && n < s);

            );
            e = Ye(t.max, o);
            return a.push(e), a;
          })(n, t));
        (t.max = q.max(n)),
          (t.min = q.min(n)),
          e.reverse
            ? ((i = !i), (t.start = t.max), (t.end = t.min))
            : ((t.start = t.min), (t.end = t.max)),
          i && n.reverse();
      },
      convertTicksToLabels: function () {
        (this.tickValues = this.ticks.slice()),
          T.prototype.convertTicksToLabels.call(this);
      },
      getLabelForIndex: function (t, e) {
        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
      },
      getPixelForTick: function (t) {
        return this.getPixelForValue(this.tickValues[t]);
      },
      _getFirstTickValue: function (t) {
        var e = Math.floor(q.log10(t));
        return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e);
      },
      getPixelForValue: function (t) {
        var e,
          i,
          n,
          a,
          o = this,
          r = o.options.ticks,
          s = r.reverse,
          l = q.log10,
          d = o._getFirstTickValue(o.minNotZero),
          u = 0;
        return (
          (t = +o.getRightValue(t)),
          (a = s
            ? ((i = o.end), (n = o.start), -1)
            : ((i = o.start), (n = o.end), 1)),
          (s = o.isHorizontal()
            ? ((e = o.width), s ? o.right : o.left)
            : ((e = o.height), (a *= -1), s ? o.top : o.bottom)),
          t !== i &&
            (0 === i &&
              ((e -= u = Ye(r.fontSize, j.global.defaultFontSize)), (i = d)),
            0 !== t && (u += (e / (l(n) - l(i))) * (l(t) - l(i))),
            (s += a * u)),
          s
        );
      },
      getValueForPixel: function (t) {
        var e,
          i,
          n = this,
          a = n.options.ticks,
          o = a.reverse,
          r = q.log10,
          s = n._getFirstTickValue(n.minNotZero),
          l = o ? ((i = n.end), n.start) : ((i = n.start), n.end);
        return (
          (o = n.isHorizontal()
            ? ((e = n.width), o ? n.right - t : t - n.left)
            : ((e = n.height), o ? t - n.top : n.bottom - t)) !== i &&
            (0 === i &&
              ((o -= n = Ye(a.fontSize, j.global.defaultFontSize)),
              (e -= n),
              (i = s)),
            (o = (o * (r(l) - r(i))) / e),
            (o = Math.pow(10, r(i) + o))),
          o
        );
      },
    }),
    Xe = ((o._defaults = a), q.valueOrDefault),
    Ke = q.valueAtIndexOrDefault,
    Ge = q.options.resolve,
    p = {
      display: !0,
      animate: !0,
      position: "chartArea",
      angleLines: {
        display: !0,
        color: "rgba(0, 0, 0, 0.1)",
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0,
      },
      gridLines: { circular: !1 },
      ticks: {
        showLabelBackdrop: !0,
        backdropColor: "rgba(255,255,255,0.75)",
        backdropPaddingY: 2,
        backdropPaddingX: 2,
        callback: m.formatters.linear,
      },
      pointLabels: {
        display: !0,
        fontSize: 10,
        callback: function (t) {
          return t;
        },
      },
    };
  function Ze(t) {
    var e = t.options;
    return e.angleLines.display || e.pointLabels.display
      ? t.chart.data.labels.length
      : 0;
  }
  function $e(t) {
    var e = t.ticks;
    return e.display && t.display
      ? Xe(e.fontSize, j.global.defaultFontSize) + 2 * e.backdropPaddingY
      : 0;
  }
  function Je(t, e, i, n, a) {
    return t === n || t === a
      ? { start: e - i / 2, end: e + i / 2 }
      : t < n || a < t
      ? { start: e - i, end: e }
      : { start: e, end: e + i };
  }
  function Qe(t) {
    return q.isNumber(t) ? t : 0;
  }
  var ee = qe.extend({
      setDimensions: function () {
        var t = this;
        (t.width = t.maxWidth),
          (t.height = t.maxHeight),
          (t.paddingTop = $e(t.options) / 2),
          (t.xCenter = Math.floor(t.width / 2)),
          (t.yCenter = Math.floor((t.height - t.paddingTop) / 2)),
          (t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2);
      },
      determineDataLimits: function () {
        var n = this,
          a = n.chart,
          o = Number.POSITIVE_INFINITY,
          r = Number.NEGATIVE_INFINITY;
        q.each(a.data.datasets, function (t, e) {
          var i;
          a.isDatasetVisible(e) &&
            ((i = a.getDatasetMeta(e)),
            q.each(t.data, function (t, e) {
              t = +n.getRightValue(t);
              isNaN(t) ||
                i.data[e].hidden ||
                ((o = Math.min(t, o)), (r = Math.max(t, r)));
            }));
        }),
          (n.min = o === Number.POSITIVE_INFINITY ? 0 : o),
          (n.max = r === Number.NEGATIVE_INFINITY ? 0 : r),
          n.handleTickRangeOptions();
      },
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / $e(this.options));
      },
      convertTicksToLabels: function () {
        var t = this;
        qe.prototype.convertTicksToLabels.call(t),
          (t.pointLabels = t.chart.data.labels.map(
            t.options.pointLabels.callback,
            t
          ));
      },
      getLabelForIndex: function (t, e) {
        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
      },
      fit: function () {
        var t = this.options;
        if (t.display && t.pointLabels.display) {
          var e,
            i = this,
            n = q.options._parseFont(i.options.pointLabels),
            a = { l: 0, r: i.width, t: 0, b: i.height - i.paddingTop },
            o = {};
          (i.ctx.font = n.string), (i._pointLabelSizes = []);
          for (var r, s = Ze(i), l = 0; l < s; l++) {
            (e = i.getPointPosition(l, i.drawingArea + 5)),
              (r = i.ctx),
              (u = n.lineHeight),
              (d = i.pointLabels[l] || ""),
              (r = q.isArray(d)
                ? { w: q.longestText(r, r.font, d), h: d.length * u }
                : { w: r.measureText(d).width, h: u }),
              (i._pointLabelSizes[l] = r);
            var d = i.getIndexAngle(l),
              u = q.toDegrees(d) % 360,
              h = Je(u, e.x, r.w, 0, 180),
              u = Je(u, e.y, r.h, 90, 270);
            h.start < a.l && ((a.l = h.start), (o.l = d)),
              h.end > a.r && ((a.r = h.end), (o.r = d)),
              u.start < a.t && ((a.t = u.start), (o.t = d)),
              u.end > a.b && ((a.b = u.end), (o.b = d));
          }
          i.setReductions(i.drawingArea, a, o);
        } else this.setCenterPoint(0, 0, 0, 0);
      },
      setReductions: function (t, e, i) {
        var n = this,
          a = e.l / Math.sin(i.l),
          o = Math.max(e.r - n.width, 0) / Math.sin(i.r),
          r = -e.t / Math.cos(i.t),
          e = -Math.max(e.b - (n.height - n.paddingTop), 0) / Math.cos(i.b),
          a = Qe(a),
          o = Qe(o),
          r = Qe(r),
          e = Qe(e);
        (n.drawingArea = Math.min(
          Math.floor(t - (a + o) / 2),
          Math.floor(t - (r + e) / 2)
        )),
          n.setCenterPoint(a, o, r, e);
      },
      setCenterPoint: function (t, e, i, n) {
        var a = this,
          e = a.width - e - a.drawingArea,
          t = t + a.drawingArea,
          i = i + a.drawingArea,
          n = a.height - a.paddingTop - n - a.drawingArea;
        (a.xCenter = Math.floor((t + e) / 2 + a.left)),
          (a.yCenter = Math.floor((i + n) / 2 + a.top + a.paddingTop));
      },
      getIndexAngle: function (t) {
        return (
          t * ((2 * Math.PI) / Ze(this)) +
          ((this.chart.options && this.chart.options.startAngle
            ? this.chart.options.startAngle
            : 0) *
            Math.PI *
            2) /
            360
        );
      },
      getDistanceFromCenterForValue: function (t) {
        var e,
          i = this;
        return null === t
          ? 0
          : ((e = i.drawingArea / (i.max - i.min)),
            i.options.ticks.reverse ? (i.max - t) * e : (t - i.min) * e);
      },
      getPointPosition: function (t, e) {
        t = this.getIndexAngle(t) - Math.PI / 2;
        return {
          x: Math.cos(t) * e + this.xCenter,
          y: Math.sin(t) * e + this.yCenter,
        };
      },
      getPointPositionForValue: function (t, e) {
        return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
      },
      getBasePosition: function () {
        var t = this.min,
          e = this.max;
        return this.getPointPositionForValue(
          0,
          this.beginAtZero ? 0 : t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0
        );
      },
      draw: function () {
        var c = this,
          t = c.options,
          f = t.gridLines,
          g = t.ticks;
        if (t.display) {
          var p = c.ctx,
            m = this.getIndexAngle(0),
            b = q.options._parseFont(g);
          if (t.angleLines.display || t.pointLabels.display) {
            var e = c;
            var i = e.ctx,
              t = e.options,
              n = t.angleLines,
              a = t.gridLines,
              o = t.pointLabels,
              r = Xe(n.lineWidth, a.lineWidth),
              s = Xe(n.color, a.color),
              l = $e(t),
              d =
                (i.save(),
                (i.lineWidth = r),
                (i.strokeStyle = s),
                i.setLineDash &&
                  (i.setLineDash(Ge([n.borderDash, a.borderDash, []])),
                  (i.lineDashOffset = Ge([
                    n.borderDashOffset,
                    a.borderDashOffset,
                    0,
                  ]))),
                e.getDistanceFromCenterForValue(
                  t.ticks.reverse ? e.min : e.max
                )),
              u = q.options._parseFont(o);
            (i.font = u.string), (i.textBaseline = "middle");
            for (var h, v, x = Ze(e) - 1; 0 <= x; x--)
              if (
                (n.display &&
                  r &&
                  s &&
                  ((M = e.getPointPosition(x, d)),
                  i.beginPath(),
                  i.moveTo(e.xCenter, e.yCenter),
                  i.lineTo(M.x, M.y),
                  i.stroke()),
                o.display)
              ) {
                var y,
                  k,
                  M = e.getPointPosition(x, d + (0 === x ? l / 2 : 0) + 5),
                  w = Ke(o.fontColor, x, j.global.defaultFontColor),
                  w = ((i.fillStyle = w), e.getIndexAngle(x)),
                  w = q.toDegrees(w),
                  _ =
                    ((i.textAlign =
                      0 === (v = w) || 180 === v
                        ? "center"
                        : v < 180
                        ? "left"
                        : "right"),
                    (v = w),
                    (w = e._pointLabelSizes[x]),
                    (h = M),
                    90 === v || 270 === v
                      ? (h.y -= w.h / 2)
                      : (270 < v || v < 90) && (h.y -= w.h),
                    (I = k = y = P = S = C = _ = void 0),
                    i),
                  C = e.pointLabels[x] || "",
                  S = M,
                  P = u.lineHeight,
                  I = S.y + P / 2;
                if (q.isArray(C))
                  for (y = 0, k = C.length; y < k; ++y)
                    _.fillText(C[y], S.x, I), (I += P);
                else _.fillText(C, S.x, I);
              }
            i.restore();
          }
          q.each(c.ticks, function (t, e) {
            if (0 < e || g.reverse) {
              var i = c.getDistanceFromCenterForValue(c.ticksAsNumbers[e]);
              if (f.display && 0 !== e) {
                var n,
                  a = c,
                  o = f,
                  r = i,
                  s = a.ctx,
                  l = o.circular,
                  d = Ze(a),
                  u = Ke(o.color, e - 1),
                  e = Ke(o.lineWidth, e - 1);
                if ((l || d) && u && e) {
                  if (
                    (s.save(),
                    (s.strokeStyle = u),
                    (s.lineWidth = e),
                    s.setLineDash &&
                      (s.setLineDash(o.borderDash || []),
                      (s.lineDashOffset = o.borderDashOffset || 0)),
                    s.beginPath(),
                    l)
                  )
                    s.arc(a.xCenter, a.yCenter, r, 0, 2 * Math.PI);
                  else {
                    (n = a.getPointPosition(0, r)), s.moveTo(n.x, n.y);
                    for (var h = 1; h < d; h++)
                      (n = a.getPointPosition(h, r)), s.lineTo(n.x, n.y);
                  }
                  s.closePath(), s.stroke(), s.restore();
                }
              }
              g.display &&
                ((u = Xe(g.fontColor, j.global.defaultFontColor)),
                (p.font = b.string),
                p.save(),
                p.translate(c.xCenter, c.yCenter),
                p.rotate(m),
                g.showLabelBackdrop &&
                  ((e = p.measureText(t).width),
                  (p.fillStyle = g.backdropColor),
                  p.fillRect(
                    -e / 2 - g.backdropPaddingX,
                    -i - b.size / 2 - g.backdropPaddingY,
                    e + 2 * g.backdropPaddingX,
                    b.size + 2 * g.backdropPaddingY
                  )),
                (p.textAlign = "center"),
                (p.textBaseline = "middle"),
                (p.fillStyle = u),
                p.fillText(t, 0, -i),
                p.restore());
            }
          });
        }
      },
    }),
    ti = ((ee._defaults = p), q.valueOrDefault),
    ei = Number.MIN_SAFE_INTEGER || -9007199254740991,
    ii = Number.MAX_SAFE_INTEGER || 9007199254740991,
    ni = {
      millisecond: {
        common: !0,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500],
      },
      second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 15, 30] },
      minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 15, 30] },
      hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] },
      day: { common: !0, size: 864e5, steps: [1, 2, 5] },
      week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] },
      month: { common: !0, size: 2628e6, steps: [1, 2, 3] },
      quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] },
      year: { common: !0, size: 3154e7 },
    },
    L = Object.keys(ni);
  function ai(t, e) {
    return t - e;
  }
  function oi(t) {
    for (var e, i = {}, n = [], a = 0, o = t.length; a < o; ++a)
      i[(e = t[a])] || ((i[e] = !0), n.push(e));
    return n;
  }
  function ri(t, e, i, n) {
    var a = (function (t, e, i) {
        for (var n, a, o, r = 0, s = t.length - 1; 0 <= r && r <= s; ) {
          if (((a = t[(n = (r + s) >> 1) - 1] || null), (o = t[n]), !a))
            return { lo: null, hi: o };
          if (o[e] < i) r = 1 + n;
          else {
            if (!(a[e] > i)) return { lo: a, hi: o };
            s = n - 1;
          }
        }
        return { lo: o, hi: null };
      })(t, e, i),
      o = a.lo ? (a.hi ? a.lo : t[t.length - 2]) : t[0],
      a = a.lo ? a.hi || t[t.length - 1] : t[1],
      t = a[e] - o[e],
      i = t ? (i - o[e]) / t : 0,
      e = (a[n] - o[n]) * i;
    return o[n] + e;
  }
  function si(t, e) {
    var i = t._adapter,
      t = t.options.time,
      n = t.parser,
      t = n || t.format,
      a = e;
    return (
      "function" == typeof n && (a = n(a)),
      null !==
      (a = q.isFinite(a)
        ? a
        : "string" == typeof t
        ? i.parse(a, t)
        : i.parse(a))
        ? +a
        : (a =
            n || "function" != typeof t || ((a = t(e)), q.isFinite(a))
              ? a
              : i.parse(a))
    );
  }
  function R(t, e) {
    var i;
    return q.isNullOrUndef(e)
      ? null
      : ((i = t.options.time),
        (e =
          null !== (e = si(t, t.getRightValue(e))) && i.round
            ? +t._adapter.startOf(e, i.round)
            : e));
  }
  function li(t) {
    for (var e = L.indexOf(t) + 1, i = L.length; e < i; ++e)
      if (ni[L[e]].common) return L[e];
  }
  var ae = T.extend({
      initialize: function () {
        this.mergeTicksOptions(), T.prototype.initialize.call(this);
      },
      update: function () {
        var t = this.options,
          e = t.time || (t.time = {}),
          t = (this._adapter = new We._date(t.adapters.date));
        return (
          e.format &&
            console.warn(
              "options.time.format is deprecated and replaced by options.time.parser."
            ),
          q.mergeIf(e.displayFormats, t.formats()),
          T.prototype.update.apply(this, arguments)
        );
      },
      getRightValue: function (t) {
        return (
          t && void 0 !== t.t && (t = t.t),
          T.prototype.getRightValue.call(this, t)
        );
      },
      determineDataLimits: function () {
        for (
          var t,
            e,
            i,
            n,
            a = this,
            o = a.chart,
            r = a._adapter,
            s = a.options.time,
            l = s.unit || "day",
            d = ii,
            u = ei,
            h = [],
            c = [],
            f = [],
            g = o.data.labels || [],
            p = 0,
            m = g.length;
          p < m;
          ++p
        )
          f.push(R(a, g[p]));
        for (p = 0, m = (o.data.datasets || []).length; p < m; ++p)
          if (o.isDatasetVisible(p))
            if (((i = o.data.datasets[p].data), q.isObject(i[0])))
              for (c[p] = [], t = 0, e = i.length; t < e; ++t)
                (n = R(a, i[t])), h.push(n), (c[p][t] = n);
            else {
              for (t = 0, e = f.length; t < e; ++t) h.push(f[t]);
              c[p] = f.slice(0);
            }
          else c[p] = [];
        f.length &&
          ((f = oi(f).sort(ai)),
          (d = Math.min(d, f[0])),
          (u = Math.max(u, f[f.length - 1]))),
          h.length &&
            ((h = oi(h).sort(ai)),
            (d = Math.min(d, h[0])),
            (u = Math.max(u, h[h.length - 1]))),
          (d = R(a, s.min) || d),
          (u = R(a, s.max) || u),
          (d = d === ii ? +r.startOf(Date.now(), l) : d),
          (u = u === ei ? +r.endOf(Date.now(), l) + 1 : u),
          (a.min = Math.min(d, u)),
          (a.max = Math.max(d + 1, u)),
          (a._horizontal = a.isHorizontal()),
          (a._table = []),
          (a._timestamps = { data: h, datasets: c, labels: f });
      },
      buildTicks: function () {
        var t,
          e,
          i,
          n,
          a,
          o,
          r,
          s,
          l = this,
          d = l.min,
          u = l.max,
          h = l.options,
          c = h.time,
          f = [],
          g = [];
        switch (h.ticks.source) {
          case "data":
            f = l._timestamps.data;
            break;
          case "labels":
            f = l._timestamps.labels;
            break;
          default:
            f = (function (t, l, d, e) {
              var i,
                n = t._adapter,
                a = (t = t.options).time,
                u =
                  a.unit ||
                  (function (t, e, i, n) {
                    for (
                      var a, o, r = L.length, s = L.indexOf(t);
                      s < r - 1;
                      ++s
                    )
                      if (
                        ((o = (a = ni[L[s]]).steps
                          ? a.steps[a.steps.length - 1]
                          : ii),
                        a.common && Math.ceil((i - e) / (o * a.size)) <= n)
                      )
                        return L[s];
                    return L[r - 1];
                  })(a.minUnit, l, d, e),
                o = li(u),
                r = ti(a.stepSize, a.unitStepSize),
                s = "week" === u && a.isoWeekday,
                t = t.ticks.major.enabled,
                h = ni[u],
                c = l,
                f = d,
                g = [],
                r =
                  r ||
                  (function (t) {
                    var e,
                      i,
                      n,
                      a = d - l,
                      o = ni[u],
                      r = o.size,
                      s = o.steps;
                    if (!s) return Math.ceil(a / (t * r));
                    for (
                      e = 0, i = s.length;
                      e < i && ((n = s[e]), !(Math.ceil(a / (r * n)) <= t));
                      ++e
                    );
                    return n;
                  })(e);
              for (
                s &&
                  ((c = +n.startOf(c, "isoWeek", s)),
                  (f = +n.startOf(f, "isoWeek", s))),
                  c = +n.startOf(c, s ? "day" : u),
                  (f = +n.startOf(f, s ? "day" : u)) < d &&
                    (f = +n.add(f, 1, u)),
                  i = c,
                  t &&
                    o &&
                    !s &&
                    !a.round &&
                    ((i = +n.startOf(i, o)),
                    (i = +n.add(i, ~~((c - i) / (h.size * r)) * r, u)));
                i < f;
                i = +n.add(i, r, u)
              )
                g.push(+i);
              return g.push(+i), g;
            })(l, d, u, l.getLabelCapacity(d));
        }
        for (
          "ticks" === h.bounds &&
            f.length &&
            ((d = f[0]), (u = f[f.length - 1])),
            d = R(l, c.min) || d,
            u = R(l, c.max) || u,
            t = 0,
            e = f.length;
          t < e;
          ++t
        )
          (i = f[t]) >= d && i <= u && g.push(i);
        (l.min = d),
          (l.max = u),
          (l._unit =
            c.unit ||
            (function (t, e, i, n, a) {
              for (var o, r = L.length - 1; r >= L.indexOf(i); r--)
                if (
                  ((o = L[r]),
                  ni[o].common && t._adapter.diff(a, n, o) >= e.length)
                )
                  return o;
              return L[i ? L.indexOf(i) : 0];
            })(l, g, c.minUnit, l.min, l.max)),
          (l._majorUnit = li(l._unit)),
          (l._table = (function (t, e, i) {
            if ("linear" === h.distribution || !t.length)
              return [
                { time: e, pos: 0 },
                { time: i, pos: 1 },
              ];
            for (var n, a, o, r = [], s = [e], l = 0, d = t.length; l < d; ++l)
              (a = t[l]) > e && a < i && s.push(a);
            for (s.push(i), l = 0, d = s.length; l < d; ++l)
              (o = s[l + 1]),
                (a = s[l]),
                (void 0 !== (n = s[l - 1]) &&
                  void 0 !== o &&
                  Math.round((o + n) / 2) === a) ||
                  r.push({ time: a, pos: l / (d - 1) });
            return r;
          })(l._timestamps.data, d, u)),
          (l._offsets =
            ((c = l._table),
            (n = g),
            (s = r = 0),
            (a = h).offset &&
              n.length &&
              (a.time.min ||
                ((o = ri(c, "time", n[0], "pos")),
                (r =
                  1 === n.length
                    ? 1 - o
                    : (ri(c, "time", n[1], "pos") - o) / 2)),
              a.time.max ||
                ((o = ri(c, "time", n[n.length - 1], "pos")),
                (s =
                  1 === n.length
                    ? o
                    : (o - ri(c, "time", n[n.length - 2], "pos")) / 2))),
            { start: r, end: s })),
          h.ticks.reverse && g.reverse();
        for (
          var p, m, b = l, v = g, x = l._majorUnit, y = [], k = 0, M = v.length;
          k < M;
          ++k
        )
          (p = v[k]),
            (m = !!x && p === +b._adapter.startOf(p, x)),
            y.push({ value: p, major: m });
        return y;
      },
      getLabelForIndex: function (t, e) {
        var i = this,
          n = i._adapter,
          a = i.chart.data,
          o = i.options.time,
          r = a.labels && t < a.labels.length ? a.labels[t] : "",
          a = a.datasets[e].data[t];
        return (
          q.isObject(a) && (r = i.getRightValue(a)),
          o.tooltipFormat
            ? n.format(si(i, r), o.tooltipFormat)
            : "string" == typeof r
            ? r
            : n.format(si(i, r), o.displayFormats.datetime)
        );
      },
      tickFormatFunction: function (t, e, i, n) {
        var a = this._adapter,
          o = this.options,
          r = o.time.displayFormats,
          s = r[this._unit],
          l = this._majorUnit,
          r = r[l],
          d = +a.startOf(t, l),
          u = o.ticks.major,
          l = u.enabled && l && r && t === d,
          d = a.format(t, n || (l ? r : s)),
          a = l ? u : o.ticks.minor,
          t = ti(a.callback, a.userCallback);
        return t ? t(d, e, i) : d;
      },
      convertTicksToLabels: function (t) {
        for (var e = [], i = 0, n = t.length; i < n; ++i)
          e.push(this.tickFormatFunction(t[i].value, i, t));
        return e;
      },
      getPixelForOffset: function (t) {
        var e = this,
          i = e.options.ticks.reverse,
          n = e._horizontal ? e.width : e.height,
          a = e._horizontal ? (i ? e.right : e.left) : i ? e.bottom : e.top,
          t = ri(e._table, "time", t, "pos"),
          n =
            (n * (e._offsets.start + t)) /
            (e._offsets.start + 1 + e._offsets.end);
        return i ? a - n : a + n;
      },
      getPixelForValue: function (t, e, i) {
        var n = null;
        if (
          null !==
          (n =
            null ===
            (n =
              void 0 !== e && void 0 !== i
                ? this._timestamps.datasets[i][e]
                : n)
              ? R(this, t)
              : n)
        )
          return this.getPixelForOffset(n);
      },
      getPixelForTick: function (t) {
        var e = this.getTicks();
        return 0 <= t && t < e.length
          ? this.getPixelForOffset(e[t].value)
          : null;
      },
      getValueForPixel: function (t) {
        var e = this,
          i = e._horizontal ? e.width : e.height,
          n = e._horizontal ? e.left : e.top,
          t =
            (i ? (t - n) / i : 0) * (e._offsets.start + 1 + e._offsets.start) -
            e._offsets.end,
          n = ri(e._table, "pos", t, "time");
        return e._adapter._create(n);
      },
      getLabelWidth: function (t) {
        var e = this.options.ticks,
          t = this.ctx.measureText(t).width,
          i = q.toRadians(e.maxRotation),
          n = Math.cos(i),
          i = Math.sin(i);
        return t * n + ti(e.fontSize, j.global.defaultFontSize) * i;
      },
      getLabelCapacity: function (t) {
        var e = this,
          i = e.options.time.displayFormats.millisecond,
          t = e.tickFormatFunction(t, 0, [], i),
          i = e.getLabelWidth(t),
          t = e.isHorizontal() ? e.width : e.height,
          e = Math.floor(t / i);
        return 0 < e ? e : 1;
      },
    }),
    a =
      ((ae._defaults = {
        position: "bottom",
        distribution: "linear",
        bounds: "data",
        adapters: {},
        time: {
          parser: !1,
          format: !1,
          unit: !1,
          round: !1,
          displayFormat: !1,
          isoWeekday: !1,
          minUnit: "millisecond",
          displayFormats: {},
        },
        ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } },
      }),
      { category: y, linear: Qt, logarithmic: o, radialLinear: ee, time: ae }),
    di = {
      datetime: "MMM D, YYYY, h:mm:ss a",
      millisecond: "h:mm:ss.SSS a",
      second: "h:mm:ss a",
      minute: "h:mm a",
      hour: "hA",
      day: "MMM D",
      week: "ll",
      month: "MMM YYYY",
      quarter: "[Q]Q - YYYY",
      year: "YYYY",
    },
    ui =
      (We._date.override(
        "function" == typeof n
          ? {
              _id: "moment",
              formats: function () {
                return di;
              },
              parse: function (t, e) {
                return (
                  "string" == typeof t && "string" == typeof e
                    ? (t = n(t, e))
                    : t instanceof n || (t = n(t)),
                  t.isValid() ? t.valueOf() : null
                );
              },
              format: function (t, e) {
                return n(t).format(e);
              },
              add: function (t, e, i) {
                return n(t).add(e, i).valueOf();
              },
              diff: function (t, e, i) {
                return n.duration(n(t).diff(n(e))).as(i);
              },
              startOf: function (t, e, i) {
                return (
                  (t = n(t)),
                  ("isoWeek" === e ? t.isoWeekday(i) : t.startOf(e)).valueOf()
                );
              },
              endOf: function (t, e) {
                return n(t).endOf(e).valueOf();
              },
              _create: function (t) {
                return n(t);
              },
            }
          : {}
      ),
      j._set("global", { plugins: { filler: { propagate: !0 } } }),
      {
        dataset: function (t) {
          var e = t.fill,
            t = t.chart,
            i = t.getDatasetMeta(e),
            n = (i && t.isDatasetVisible(e) && i.dataset._children) || [],
            a = n.length || 0;
          return a
            ? function (t, e) {
                return (e < a && n[e]._view) || null;
              }
            : null;
        },
        boundary: function (t) {
          var t = t.boundary,
            e = t ? t.x : null,
            i = t ? t.y : null;
          return function (t) {
            return { x: null === e ? t.x : e, y: null === i ? t.y : i };
          };
        },
      });
  function hi(t) {
    return t && !t.skip;
  }
  function ci(t, e, i, n, a) {
    var o;
    if (n && a) {
      for (t.moveTo(e[0].x, e[0].y), o = 1; o < n; ++o)
        q.canvas.lineTo(t, e[o - 1], e[o]);
      for (t.lineTo(i[a - 1].x, i[a - 1].y), o = a - 1; 0 < o; --o)
        q.canvas.lineTo(t, i[o], i[o - 1], !0);
    }
  }
  var p = {
      id: "filler",
      afterDatasetsUpdate: function (t, e) {
        for (
          var i,
            n,
            a,
            o,
            r,
            s,
            l = (t.data.datasets || []).length,
            d = e.propagate,
            u = [],
            h = 0;
          h < l;
          ++h
        )
          (a = null),
            (n = (i = t.getDatasetMeta(h)).dataset) &&
              n._model &&
              n instanceof v.Line &&
              (a = {
                visible: t.isDatasetVisible(h),
                fill: (function (t, e, i) {
                  var n = (t = t._model || {}).fill;
                  if (
                    !1 === (n = void 0 === n ? !!t.backgroundColor : n) ||
                    null === n
                  )
                    return !1;
                  if (!0 === n) return "origin";
                  if (
                    ((t = parseFloat(n, 10)),
                    isFinite(t) && Math.floor(t) === t)
                  )
                    return (
                      !(
                        (t = "-" !== n[0] && "+" !== n[0] ? t : e + t) === e ||
                        t < 0 ||
                        i <= t
                      ) && t
                    );
                  switch (n) {
                    case "bottom":
                      return "start";
                    case "top":
                      return "end";
                    case "zero":
                      return "origin";
                    case "origin":
                    case "start":
                    case "end":
                      return n;
                    default:
                      return !1;
                  }
                })(n, h, l),
                chart: t,
                el: n,
              }),
            (i.$filler = a),
            u.push(a);
        for (h = 0; h < l; ++h)
          (a = u[h]) &&
            ((a.fill = (function (t, e, i) {
              var n,
                a = t[e].fill,
                o = [e];
              if (!i) return a;
              for (; !1 !== a && -1 === o.indexOf(a); ) {
                if (!isFinite(a)) return a;
                if (!(n = t[a])) return !1;
                if (n.visible) return a;
                o.push(a), (a = n.fill);
              }
              return !1;
            })(u, h, d)),
            (a.boundary = (function (t) {
              var e = t.el._model || {},
                i = t.el._scale || {},
                t = t.fill,
                n = null;
              if (
                !isFinite(t) &&
                ("start" === t
                  ? (n = void 0 === e.scaleBottom ? i.bottom : e.scaleBottom)
                  : "end" === t
                  ? (n = void 0 === e.scaleTop ? i.top : e.scaleTop)
                  : void 0 !== e.scaleZero
                  ? (n = e.scaleZero)
                  : i.getBasePosition
                  ? (n = i.getBasePosition())
                  : i.getBasePixel && (n = i.getBasePixel()),
                null != n)
              ) {
                if (void 0 !== n.x && void 0 !== n.y) return n;
                if (q.isFinite(n))
                  return {
                    x: (t = i.isHorizontal()) ? n : null,
                    y: t ? null : n,
                  };
              }
              return null;
            })(a)),
            (a.mapper =
              ((s = r = void 0),
              (r = (o = a).fill),
              !(s = "dataset") === r
                ? null
                : (isFinite(r) || (s = "boundary"), ui[s](o)))));
      },
      beforeDatasetDraw: function (t, e) {
        e = e.meta.$filler;
        if (e) {
          var i = t.ctx,
            n = e.el,
            a = n._view,
            o = n._children || [],
            e = e.mapper,
            r = a.backgroundColor || j.global.defaultColor;
          if (e && r && o.length) {
            q.canvas.clipArea(i, t.chartArea);
            var s,
              l,
              d,
              u,
              h,
              c,
              f = i,
              g = o,
              p = e,
              m = a,
              t = r,
              o = n._loop,
              b = g.length,
              v = m.spanGaps,
              x = [],
              y = [],
              k = 0,
              M = 0;
            for (f.beginPath(), s = 0, l = b + !!o; s < l; ++s)
              (u = p((d = g[(u = s % b)]._view), u, m)),
                (h = hi(d)),
                (c = hi(u)),
                h && c
                  ? ((k = x.push(d)), (M = y.push(u)))
                  : k &&
                    M &&
                    (v
                      ? (h && x.push(d), c && y.push(u))
                      : (ci(f, x, y, k, M), (k = M = 0), (x = []), (y = [])));
            ci(f, x, y, k, M),
              f.closePath(),
              (f.fillStyle = t),
              f.fill(),
              q.canvas.unclipArea(i);
          }
        }
      },
    },
    y = q.noop,
    O = q.valueOrDefault;
  function fi(t, e) {
    return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth;
  }
  j._set("global", {
    legend: {
      display: !0,
      position: "top",
      fullWidth: !0,
      reverse: !1,
      weight: 1e3,
      onClick: function (t, e) {
        var e = e.datasetIndex,
          i = this.chart,
          n = i.getDatasetMeta(e);
        (n.hidden = null === n.hidden ? !i.data.datasets[e].hidden : null),
          i.update();
      },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        generateLabels: function (i) {
          var t = i.data;
          return q.isArray(t.datasets)
            ? t.datasets.map(function (t, e) {
                return {
                  text: t.label,
                  fillStyle: q.isArray(t.backgroundColor)
                    ? t.backgroundColor[0]
                    : t.backgroundColor,
                  hidden: !i.isDatasetVisible(e),
                  lineCap: t.borderCapStyle,
                  lineDash: t.borderDash,
                  lineDashOffset: t.borderDashOffset,
                  lineJoin: t.borderJoinStyle,
                  lineWidth: t.borderWidth,
                  strokeStyle: t.borderColor,
                  pointStyle: t.pointStyle,
                  datasetIndex: e,
                };
              }, this)
            : [];
        },
      },
    },
    legendCallback: function (t) {
      var e = [];
      e.push('<ul class="' + t.id + '-legend">');
      for (var i = 0; i < t.data.datasets.length; i++)
        e.push(
          '<li><span style="background-color:' +
            t.data.datasets[i].backgroundColor +
            '"></span>'
        ),
          t.data.datasets[i].label && e.push(t.data.datasets[i].label),
          e.push("</li>");
      return e.push("</ul>"), e.join("");
    },
  });
  var gi = t.extend({
    initialize: function (t) {
      q.extend(this, t),
        (this.legendHitBoxes = []),
        (this._hoveredItem = null),
        (this.doughnutMode = !1);
    },
    beforeUpdate: y,
    update: function (t, e, i) {
      var n = this;
      return (
        n.beforeUpdate(),
        (n.maxWidth = t),
        (n.maxHeight = e),
        (n.margins = i),
        n.beforeSetDimensions(),
        n.setDimensions(),
        n.afterSetDimensions(),
        n.beforeBuildLabels(),
        n.buildLabels(),
        n.afterBuildLabels(),
        n.beforeFit(),
        n.fit(),
        n.afterFit(),
        n.afterUpdate(),
        n.minSize
      );
    },
    afterUpdate: y,
    beforeSetDimensions: y,
    setDimensions: function () {
      var t = this;
      t.isHorizontal()
        ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
        : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
        (t.paddingLeft = 0),
        (t.paddingTop = 0),
        (t.paddingRight = 0),
        (t.paddingBottom = 0),
        (t.minSize = { width: 0, height: 0 });
    },
    afterSetDimensions: y,
    beforeBuildLabels: y,
    buildLabels: function () {
      var e = this,
        i = e.options.labels || {},
        t = q.callback(i.generateLabels, [e.chart], e) || [];
      i.filter &&
        (t = t.filter(function (t) {
          return i.filter(t, e.chart.data);
        })),
        e.options.reverse && t.reverse(),
        (e.legendItems = t);
    },
    afterBuildLabels: y,
    beforeFit: y,
    fit: function () {
      var i,
        n,
        a,
        o,
        r,
        s,
        l,
        d,
        t = this,
        e = t.options,
        u = e.labels,
        e = e.display,
        h = t.ctx,
        c = q.options._parseFont(u),
        f = c.size,
        g = (t.legendHitBoxes = []),
        p = t.minSize,
        m = t.isHorizontal();
      m
        ? ((p.width = t.maxWidth), (p.height = e ? 10 : 0))
        : ((p.width = e ? 10 : 0), (p.height = t.maxHeight)),
        e &&
          ((h.font = c.string),
          m
            ? ((i = t.lineWidths = [0]),
              (n = 0),
              (h.textAlign = "left"),
              (h.textBaseline = "top"),
              q.each(t.legendItems, function (t, e) {
                t = fi(u, f) + f / 2 + h.measureText(t.text).width;
                (0 === e || i[i.length - 1] + t + u.padding > p.width) &&
                  ((n += f + u.padding),
                  (i[i.length - (0 < e ? 0 : 1)] = u.padding)),
                  (g[e] = { left: 0, top: 0, width: t, height: f }),
                  (i[i.length - 1] += t + u.padding);
              }),
              (p.height += n))
            : ((a = u.padding),
              (o = t.columnWidths = []),
              (r = u.padding),
              (l = s = 0),
              (d = f + a),
              q.each(t.legendItems, function (t, e) {
                t = fi(u, f) + f / 2 + h.measureText(t.text).width;
                0 < e &&
                  l + d > p.height - a &&
                  ((r += s + u.padding), o.push(s), (l = s = 0)),
                  (s = Math.max(s, t)),
                  (l += d),
                  (g[e] = { left: 0, top: 0, width: t, height: f });
              }),
              (r += s),
              o.push(s),
              (p.width += r))),
        (t.width = p.width),
        (t.height = p.height);
    },
    afterFit: y,
    isHorizontal: function () {
      return (
        "top" === this.options.position || "bottom" === this.options.position
      );
    },
    draw: function () {
      var h,
        t,
        c,
        f,
        g,
        p,
        m,
        b,
        v = this,
        x = v.options,
        y = x.labels,
        e = j.global,
        k = e.defaultColor,
        M = e.elements.line,
        w = v.width,
        _ = v.lineWidths;
      x.display &&
        ((h = v.ctx),
        (e = O(y.fontColor, e.defaultFontColor)),
        (t = q.options._parseFont(y)),
        (c = t.size),
        (h.textAlign = "left"),
        (h.textBaseline = "middle"),
        (h.lineWidth = 0.5),
        (h.strokeStyle = e),
        (h.fillStyle = e),
        (h.font = t.string),
        (f = fi(y, c)),
        (g = v.legendHitBoxes),
        (p = v.isHorizontal()),
        (m = p
          ? {
              x: v.left + (w - _[0]) / 2 + y.padding,
              y: v.top + y.padding,
              line: 0,
            }
          : { x: v.left + y.padding, y: v.top + y.padding, line: 0 }),
        (b = c + y.padding),
        q.each(v.legendItems, function (t, e) {
          var i,
            n,
            a,
            o,
            r,
            s = h.measureText(t.text).width,
            l = f + c / 2 + s,
            d = m.x,
            u = m.y;
          p
            ? 0 < e &&
              d + l + y.padding > v.left + v.minSize.width &&
              ((u = m.y += b),
              m.line++,
              (d = m.x = v.left + (w - _[m.line]) / 2 + y.padding))
            : 0 < e &&
              u + b > v.top + v.minSize.height &&
              ((d = m.x = d + v.columnWidths[m.line] + y.padding),
              (u = m.y = v.top + y.padding),
              m.line++),
            (i = d),
            (n = u),
            (a = t),
            isNaN(f) ||
              f <= 0 ||
              (h.save(),
              (o = O(a.lineWidth, M.borderWidth)),
              (h.fillStyle = O(a.fillStyle, k)),
              (h.lineCap = O(a.lineCap, M.borderCapStyle)),
              (h.lineDashOffset = O(a.lineDashOffset, M.borderDashOffset)),
              (h.lineJoin = O(a.lineJoin, M.borderJoinStyle)),
              (h.lineWidth = o),
              (h.strokeStyle = O(a.strokeStyle, k)),
              h.setLineDash && h.setLineDash(O(a.lineDash, M.borderDash)),
              x.labels && x.labels.usePointStyle
                ? ((r = (f * Math.SQRT2) / 2),
                  q.canvas.drawPoint(h, a.pointStyle, r, i + f / 2, n + c / 2))
                : (0 !== o && h.strokeRect(i, n, f, c), h.fillRect(i, n, f, c)),
              h.restore()),
            (g[e].left = d),
            (g[e].top = u),
            (a = t),
            (r = s),
            (i = f + (o = c / 2) + d),
            (o = u + o),
            h.fillText(a.text, i, o),
            a.hidden &&
              (h.beginPath(),
              (h.lineWidth = 2),
              h.moveTo(i, o),
              h.lineTo(i + r, o),
              h.stroke()),
            p ? (m.x += l + y.padding) : (m.y += b);
        }));
    },
    _getLegendItemAt: function (t, e) {
      var i,
        n,
        a,
        o = this;
      if (t >= o.left && t <= o.right && e >= o.top && e <= o.bottom)
        for (a = o.legendHitBoxes, i = 0; i < a.length; ++i)
          if (
            t >= (n = a[i]).left &&
            t <= n.left + n.width &&
            e >= n.top &&
            e <= n.top + n.height
          )
            return o.legendItems[i];
      return null;
    },
    handleEvent: function (t) {
      var e,
        i = this,
        n = i.options,
        a = "mouseup" === t.type ? "click" : t.type;
      if ("mousemove" === a) {
        if (!n.onHover && !n.onLeave) return;
      } else {
        if ("click" !== a) return;
        if (!n.onClick) return;
      }
      (e = i._getLegendItemAt(t.x, t.y)),
        "click" === a
          ? e && n.onClick && n.onClick.call(i, t.native, e)
          : (n.onLeave &&
              e !== i._hoveredItem &&
              (i._hoveredItem && n.onLeave.call(i, t.native, i._hoveredItem),
              (i._hoveredItem = e)),
            n.onHover && e && n.onHover.call(i, t.native, e));
    },
  });
  function pi(t, e) {
    var i = new gi({ ctx: t.ctx, options: e, chart: t });
    M.configure(t, i, e), M.addBox(t, i), (t.legend = i);
  }
  var Qt = {
      id: "legend",
      _element: gi,
      beforeInit: function (t) {
        var e = t.options.legend;
        e && pi(t, e);
      },
      beforeUpdate: function (t) {
        var e = t.options.legend,
          i = t.legend;
        e
          ? (q.mergeIf(e, j.global.legend),
            i ? (M.configure(t, i, e), (i.options = e)) : pi(t, e))
          : i && (M.removeBox(t, i), delete t.legend);
      },
      afterEvent: function (t, e) {
        t = t.legend;
        t && t.handleEvent(e);
      },
    },
    o = q.noop,
    mi =
      (j._set("global", {
        title: {
          display: !1,
          fontStyle: "bold",
          fullWidth: !0,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3,
        },
      }),
      t.extend({
        initialize: function (t) {
          q.extend(this, t), (this.legendHitBoxes = []);
        },
        beforeUpdate: o,
        update: function (t, e, i) {
          var n = this;
          return (
            n.beforeUpdate(),
            (n.maxWidth = t),
            (n.maxHeight = e),
            (n.margins = i),
            n.beforeSetDimensions(),
            n.setDimensions(),
            n.afterSetDimensions(),
            n.beforeBuildLabels(),
            n.buildLabels(),
            n.afterBuildLabels(),
            n.beforeFit(),
            n.fit(),
            n.afterFit(),
            n.afterUpdate(),
            n.minSize
          );
        },
        afterUpdate: o,
        beforeSetDimensions: o,
        setDimensions: function () {
          var t = this;
          t.isHorizontal()
            ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
            : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
            (t.paddingLeft = 0),
            (t.paddingTop = 0),
            (t.paddingRight = 0),
            (t.paddingBottom = 0),
            (t.minSize = { width: 0, height: 0 });
        },
        afterSetDimensions: o,
        beforeBuildLabels: o,
        buildLabels: o,
        afterBuildLabels: o,
        beforeFit: o,
        fit: function () {
          var t = this,
            e = t.options,
            i = e.display,
            n = t.minSize,
            a = q.isArray(e.text) ? e.text.length : 1,
            o = q.options._parseFont(e),
            i = i ? a * o.lineHeight + 2 * e.padding : 0;
          t.isHorizontal()
            ? ((n.width = t.maxWidth), (n.height = i))
            : ((n.width = i), (n.height = t.maxHeight)),
            (t.width = n.width),
            (t.height = n.height);
        },
        afterFit: o,
        isHorizontal: function () {
          var t = this.options.position;
          return "top" === t || "bottom" === t;
        },
        draw: function () {
          var t = this,
            e = t.ctx,
            i = t.options;
          if (i.display) {
            var n,
              a,
              o,
              r = q.options._parseFont(i),
              s = r.lineHeight,
              l = s / 2 + i.padding,
              d = 0,
              u = t.top,
              h = t.left,
              c = t.bottom,
              f = t.right,
              g =
                ((e.fillStyle = q.valueOrDefault(
                  i.fontColor,
                  j.global.defaultFontColor
                )),
                (e.font = r.string),
                t.isHorizontal()
                  ? ((a = h + (f - h) / 2), (o = u + l), (n = f - h))
                  : ((a = "left" === i.position ? h + l : f - l),
                    (o = u + (c - u) / 2),
                    (n = c - u),
                    (d = Math.PI * ("left" === i.position ? -0.5 : 0.5))),
                e.save(),
                e.translate(a, o),
                e.rotate(d),
                (e.textAlign = "center"),
                (e.textBaseline = "middle"),
                i.text);
            if (q.isArray(g))
              for (var p = 0, m = 0; m < g.length; ++m)
                e.fillText(g[m], 0, p, n), (p += s);
            else e.fillText(g, 0, 0, n);
            e.restore();
          }
        },
      }));
  function bi(t, e) {
    var i = new mi({ ctx: t.ctx, options: e, chart: t });
    M.configure(t, i, e), M.addBox(t, i), (t.titleBlock = i);
  }
  var vi,
    z = {},
    ee = Qt,
    ae = {
      id: "title",
      _element: mi,
      beforeInit: function (t) {
        var e = t.options.title;
        e && bi(t, e);
      },
      beforeUpdate: function (t) {
        var e = t.options.title,
          i = t.titleBlock;
        e
          ? (q.mergeIf(e, j.global.title),
            i ? (M.configure(t, i, e), (i.options = e)) : bi(t, e))
          : i && (M.removeBox(t, i), delete t.titleBlock);
      },
    };
  for (vi in ((z.filler = p),
  (z.legend = ee),
  (z.title = ae),
  ((A.helpers = q).where = function (t, e) {
    var i;
    return q.isArray(t) && Array.prototype.filter
      ? t.filter(e)
      : ((i = []),
        q.each(t, function (t) {
          e(t) && i.push(t);
        }),
        i);
  }),
  (q.findIndex = Array.prototype.findIndex
    ? function (t, e, i) {
        return t.findIndex(e, i);
      }
    : function (t, e, i) {
        i = void 0 === i ? t : i;
        for (var n = 0, a = t.length; n < a; ++n)
          if (e.call(i, t[n], n, t)) return n;
        return -1;
      }),
  (q.findNextWhere = function (t, e, i) {
    for (var n = (i = q.isNullOrUndef(i) ? -1 : i) + 1; n < t.length; n++) {
      var a = t[n];
      if (e(a)) return a;
    }
  }),
  (q.findPreviousWhere = function (t, e, i) {
    for (var n = (i = q.isNullOrUndef(i) ? t.length : i) - 1; 0 <= n; n--) {
      var a = t[n];
      if (e(a)) return a;
    }
  }),
  (q.isNumber = function (t) {
    return !isNaN(parseFloat(t)) && isFinite(t);
  }),
  (q.almostEquals = function (t, e, i) {
    return Math.abs(t - e) < i;
  }),
  (q.almostWhole = function (t, e) {
    var i = Math.round(t);
    return i - e < t && t < i + e;
  }),
  (q.max = function (t) {
    return t.reduce(function (t, e) {
      return isNaN(e) ? t : Math.max(t, e);
    }, Number.NEGATIVE_INFINITY);
  }),
  (q.min = function (t) {
    return t.reduce(function (t, e) {
      return isNaN(e) ? t : Math.min(t, e);
    }, Number.POSITIVE_INFINITY);
  }),
  (q.sign = Math.sign
    ? function (t) {
        return Math.sign(t);
      }
    : function (t) {
        return 0 == (t = +t) || isNaN(t) ? t : 0 < t ? 1 : -1;
      }),
  (q.log10 = Math.log10
    ? function (t) {
        return Math.log10(t);
      }
    : function (t) {
        var e = Math.log(t) * Math.LOG10E,
          i = Math.round(e);
        return t === Math.pow(10, i) ? i : e;
      }),
  (q.toRadians = function (t) {
    return t * (Math.PI / 180);
  }),
  (q.toDegrees = function (t) {
    return t * (180 / Math.PI);
  }),
  (q._decimalPlaces = function (t) {
    if (q.isFinite(t)) {
      for (var e = 1, i = 0; Math.round(t * e) / e !== t; ) (e *= 10), i++;
      return i;
    }
  }),
  (q.getAngleFromPoint = function (t, e) {
    var i = e.x - t.x,
      e = e.y - t.y,
      t = Math.sqrt(i * i + e * e),
      e = Math.atan2(e, i);
    return e < -0.5 * Math.PI && (e += 2 * Math.PI), { angle: e, distance: t };
  }),
  (q.distanceBetweenPoints = function (t, e) {
    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
  }),
  (q.aliasPixel = function (t) {
    return t % 2 == 0 ? 0 : 0.5;
  }),
  (q._alignPixel = function (t, e, i) {
    (t = t.currentDevicePixelRatio), (i /= 2);
    return Math.round((e - i) * t) / t + i;
  }),
  (q.splineCurve = function (t, e, i, n) {
    var t = t.skip ? e : t,
      a = e,
      e = i.skip ? e : i,
      i = Math.sqrt(Math.pow(a.x - t.x, 2) + Math.pow(a.y - t.y, 2)),
      o = Math.sqrt(Math.pow(e.x - a.x, 2) + Math.pow(e.y - a.y, 2)),
      r = i / (i + o),
      i = o / (i + o),
      o = n * (isNaN(r) ? 0 : r),
      r = n * (isNaN(i) ? 0 : i);
    return {
      previous: { x: a.x - o * (e.x - t.x), y: a.y - o * (e.y - t.y) },
      next: { x: a.x + r * (e.x - t.x), y: a.y + r * (e.y - t.y) },
    };
  }),
  (q.EPSILON = Number.EPSILON || 1e-14),
  (q.splineCurveMonotone = function (t) {
    for (
      var e,
        i,
        n,
        a,
        o,
        r,
        s,
        l,
        d = (t || []).map(function (t) {
          return { model: t._model, deltaK: 0, mK: 0 };
        }),
        u = d.length,
        h = 0;
      h < u;
      ++h
    )
      (e = d[h]).model.skip ||
        ((l = 0 < h ? d[h - 1] : null),
        (i = h < u - 1 ? d[h + 1] : null) &&
          !i.model.skip &&
          ((s = i.model.x - e.model.x),
          (e.deltaK = 0 != s ? (i.model.y - e.model.y) / s : 0)),
        !l || l.model.skip
          ? (e.mK = e.deltaK)
          : !i || i.model.skip
          ? (e.mK = l.deltaK)
          : this.sign(l.deltaK) !== this.sign(e.deltaK)
          ? (e.mK = 0)
          : (e.mK = (l.deltaK + e.deltaK) / 2));
    for (h = 0; h < u - 1; ++h)
      (e = d[h]),
        (i = d[h + 1]),
        e.model.skip ||
          i.model.skip ||
          (q.almostEquals(e.deltaK, 0, this.EPSILON)
            ? (e.mK = i.mK = 0)
            : ((n = e.mK / e.deltaK),
              (a = i.mK / e.deltaK),
              (o = Math.pow(n, 2) + Math.pow(a, 2)) <= 9 ||
                ((o = 3 / Math.sqrt(o)),
                (e.mK = n * o * e.deltaK),
                (i.mK = a * o * e.deltaK))));
    for (h = 0; h < u; ++h)
      (e = d[h]).model.skip ||
        ((l = 0 < h ? d[h - 1] : null),
        (i = h < u - 1 ? d[h + 1] : null),
        l &&
          !l.model.skip &&
          ((r = (e.model.x - l.model.x) / 3),
          (e.model.controlPointPreviousX = e.model.x - r),
          (e.model.controlPointPreviousY = e.model.y - r * e.mK)),
        i &&
          !i.model.skip &&
          ((r = (i.model.x - e.model.x) / 3),
          (e.model.controlPointNextX = e.model.x + r),
          (e.model.controlPointNextY = e.model.y + r * e.mK)));
  }),
  (q.nextItem = function (t, e, i) {
    return i
      ? e >= t.length - 1
        ? t[0]
        : t[e + 1]
      : e >= t.length - 1
      ? t[t.length - 1]
      : t[e + 1];
  }),
  (q.previousItem = function (t, e, i) {
    return i ? (e <= 0 ? t[t.length - 1] : t[e - 1]) : e <= 0 ? t[0] : t[e - 1];
  }),
  (q.niceNum = function (t, e) {
    var i = Math.floor(q.log10(t)),
      t = t / Math.pow(10, i);
    return (
      (e
        ? t < 1.5
          ? 1
          : t < 3
          ? 2
          : t < 7
          ? 5
          : 10
        : t <= 1
        ? 1
        : t <= 2
        ? 2
        : t <= 5
        ? 5
        : 10) * Math.pow(10, i)
    );
  }),
  (q.requestAnimFrame =
    "undefined" == typeof window
      ? function (t) {
          t();
        }
      : window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (t) {
          return window.setTimeout(t, 1e3 / 60);
        }),
  (q.getRelativePosition = function (t, e) {
    var i,
      n = t.originalEvent || t,
      t = t.target || t.srcElement,
      a = t.getBoundingClientRect(),
      o = n.touches,
      o = (
        o && 0 < o.length ? ((i = o[0].clientX), o[0]) : ((i = n.clientX), n)
      ).clientY,
      n = parseFloat(q.getStyle(t, "padding-left")),
      r = parseFloat(q.getStyle(t, "padding-top")),
      s = parseFloat(q.getStyle(t, "padding-right")),
      l = parseFloat(q.getStyle(t, "padding-bottom")),
      s = a.right - a.left - n - s,
      l = a.bottom - a.top - r - l;
    return {
      x: (i = Math.round(
        (((i - a.left - n) / s) * t.width) / e.currentDevicePixelRatio
      )),
      y: (o = Math.round(
        (((o - a.top - r) / l) * t.height) / e.currentDevicePixelRatio
      )),
    };
  }),
  (q.getConstraintWidth = function (t) {
    return ki(t, "max-width", "clientWidth");
  }),
  (q.getConstraintHeight = function (t) {
    return ki(t, "max-height", "clientHeight");
  }),
  (q._calculatePadding = function (t, e, i) {
    return -1 < (e = q.getStyle(t, e)).indexOf("%")
      ? (i * parseInt(e, 10)) / 100
      : parseInt(e, 10);
  }),
  (q._getParentNode = function (t) {
    t = t.parentNode;
    return (t = t && "[object ShadowRoot]" === t.toString() ? t.host : t);
  }),
  (q.getMaximumWidth = function (t) {
    var e,
      i = q._getParentNode(t);
    return i
      ? ((i =
          (e = i.clientWidth) -
          q._calculatePadding(i, "padding-left", e) -
          q._calculatePadding(i, "padding-right", e)),
        (e = q.getConstraintWidth(t)),
        isNaN(e) ? i : Math.min(i, e))
      : t.clientWidth;
  }),
  (q.getMaximumHeight = function (t) {
    var e,
      i = q._getParentNode(t);
    return i
      ? ((i =
          (e = i.clientHeight) -
          q._calculatePadding(i, "padding-top", e) -
          q._calculatePadding(i, "padding-bottom", e)),
        (e = q.getConstraintHeight(t)),
        isNaN(e) ? i : Math.min(i, e))
      : t.clientHeight;
  }),
  (q.getStyle = function (t, e) {
    return t.currentStyle
      ? t.currentStyle[e]
      : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);
  }),
  (q.retinaScale = function (t, e) {
    var i,
      n,
      a,
      e = (t.currentDevicePixelRatio =
        e || ("undefined" != typeof window && window.devicePixelRatio) || 1);
    1 !== e &&
      ((i = t.canvas),
      (n = t.height),
      (a = t.width),
      (i.height = n * e),
      (i.width = a * e),
      t.ctx.scale(e, e),
      i.style.height ||
        i.style.width ||
        ((i.style.height = n + "px"), (i.style.width = a + "px")));
  }),
  (q.fontString = function (t, e, i) {
    return e + " " + t + "px " + i;
  }),
  (q.longestText = function (e, t, i, n) {
    var a = ((n = n || {}).data = n.data || {}),
      o = (n.garbageCollect = n.garbageCollect || []),
      r =
        (n.font !== t &&
          ((a = n.data = {}), (o = n.garbageCollect = []), (n.font = t)),
        (e.font = t),
        0),
      s =
        (q.each(i, function (t) {
          null != t && !0 !== q.isArray(t)
            ? (r = q.measureText(e, a, o, r, t))
            : q.isArray(t) &&
              q.each(t, function (t) {
                null == t || q.isArray(t) || (r = q.measureText(e, a, o, r, t));
              });
        }),
        o.length / 2);
    if (s > i.length) {
      for (var l = 0; l < s; l++) delete a[o[l]];
      o.splice(0, s);
    }
    return r;
  }),
  (q.measureText = function (t, e, i, n, a) {
    var o = e[a];
    return (
      o || ((o = e[a] = t.measureText(a).width), i.push(a)), (n = n < o ? o : n)
    );
  }),
  (q.numberOfLabelLines = function (t) {
    var e = 1;
    return (
      q.each(t, function (t) {
        q.isArray(t) && t.length > e && (e = t.length);
      }),
      e
    );
  }),
  (q.color = _t
    ? function (t) {
        return (
          t instanceof CanvasGradient && (t = j.global.defaultColor), _t(t)
        );
      }
    : function (t) {
        return console.error("Color.js not found!"), t;
      }),
  (q.getHoverColor = function (t) {
    return t instanceof CanvasPattern || t instanceof CanvasGradient
      ? t
      : q.color(t).saturate(0.5).darken(0.1).rgbString();
  }),
  (A._adapters = We),
  (A.Animation = Ft),
  (A.animationService = Lt),
  (A.controllers = oe),
  (A.DatasetController = h),
  (A.defaults = j),
  (A.Element = t),
  (A.elements = v),
  (A.Interaction = he),
  (A.layouts = M),
  (A.platform = Pe),
  (A.plugins = _),
  (A.Scale = T),
  (A.scaleService = Ie),
  (A.Ticks = m),
  (A.Tooltip = Le),
  A.helpers.each(a, function (t, e) {
    A.scaleService.registerScaleType(e, t, t._defaults);
  }),
  z))
    z.hasOwnProperty(vi) && A.plugins.register(z[vi]);
  function xi(t, e, i) {
    var n;
    return (
      "string" == typeof t
        ? ((n = parseInt(t, 10)),
          -1 !== t.indexOf("%") && (n = (n / 100) * e.parentNode[i]))
        : (n = t),
      n
    );
  }
  function yi(t) {
    return null != t && "none" !== t;
  }
  function ki(t, e, i) {
    var n = document.defaultView,
      a = q._getParentNode(t),
      o = n.getComputedStyle(t)[e],
      n = n.getComputedStyle(a)[e],
      e = yi(o),
      r = yi(n),
      s = Number.POSITIVE_INFINITY;
    return e || r ? Math.min(e ? xi(o, t, i) : s, r ? xi(n, a, i) : s) : "none";
  }
  A.platform.initialize();
  y = A;
  return (
    "undefined" != typeof window && (window.Chart = A),
    ((A.Chart = A).Legend = z.legend._element),
    (A.Title = z.title._element),
    (A.pluginService = A.plugins),
    (A.PluginBase = A.Element.extend({})),
    (A.canvasHelpers = A.helpers.canvas),
    (A.layoutService = A.layouts),
    (A.LinearScaleBase = qe),
    A.helpers.each(
      ["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"],
      function (i) {
        A[i] = function (t, e) {
          return new A(
            t,
            A.helpers.merge(e || {}, {
              type: i.charAt(0).toLowerCase() + i.slice(1),
            })
          );
        };
      }
    ),
    y
  );
});
